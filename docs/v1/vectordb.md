<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# vectordb

```go
import "github.com/Aleph-Alpha/std/v1/vectordb"
```

Package vectordb provides a database\-agnostic abstraction for vector similarity search.

### Overview

This package defines a common interface [Service](<#Service>) that can be implemented by different vector database adapters \(Qdrant, pgVector, etc.\), allowing applications to switch between databases without changing application code.

### Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                    Application Layer                        │
│  (uses vectordb.Service - no DB-specific imports)           │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│                  vectordb.Service                           │
│          (common interface + DB-agnostic types)             │
└──────────────────────────┬──────────────────────────────────┘
                           │
              ┌────────────┴────────────┐
              ▼                         ▼
      ┌───────────────┐         ┌───────────────-┐
      │ qdrant.Adapter│         │pgvector.Adapter│
      │  (implements) │         │  (planned)     │
      └───────────────┘         └───────────────-┘
```

### Benefits

- Single Source of Truth: Filter types, search interfaces, and result types defined once.
- Easy to Add New DBs: Just add a new adapter; consuming projects don't change.
- Consistent API: All projects using std get the same interface.
- Testability: Mock the interface once, works for all DBs.

### Usage

In your application, depend only on the vectordb interface:

```
import "github.com/Aleph-Alpha/std/v1/vectordb"

type SearchService struct {
    db vectordb.Service
}

func NewSearchService(db vectordb.Service) *SearchService {
    return &SearchService{db: db}
}

func (s *SearchService) Search(ctx context.Context, query string, vector []float32) ([]vectordb.SearchResult, error) {
    results, err := s.db.Search(ctx, vectordb.SearchRequest{
        CollectionName: "documents",
        Vector:         vector,
        TopK:           10,
        Filters: []*vectordb.FilterSet{
            {
                Must: &vectordb.ConditionSet{
                    Conditions: []vectordb.FilterCondition{
                        vectordb.NewMatch("status", "published"),
                    },
                },
            },
        },
    })
    if err != nil {
        return nil, err
    }
    return results[0], nil
}
```

### Wire Up with Qdrant

In your main setup:

```
import (
    "github.com/Aleph-Alpha/std/v1/vectordb"
    "github.com/Aleph-Alpha/std/v1/qdrant"
)

func main() {
    // Create Qdrant client (with health checks, config, etc.)
    qc, _ := qdrant.NewQdrantClient(qdrant.QdrantParams{
        Config: &qdrant.Config{Endpoint: "localhost", Port: 6334},
    })

    // Create adapter for DB-agnostic usage
    db := qdrant.NewAdapter(qc.Client())

    // Use in application
    svc := NewSearchService(db)
    // ...
}
```

### Package Layout

```
vectordb/
├── interface.go      # Service interface
├── types.go          # SearchRequest, SearchResult, EmbeddingInput, Collection
├── filters.go        # FilterSet, FilterCondition, and condition types
├── utils.go          # Convenience constructors (New*) and JSON helpers
└── doc.go            # This file

qdrant/                      # Qdrant package (includes adapter)
├── client.go                # QdrantClient wrapper
├── operations.go            # Adapter - implements Service
├── converter.go             # vectordb types → qdrant types
└── ...
```

Future adapters would live in their own packages:

```
pgvector/             # (planned) PostgreSQL pgvector adapter
```

### Filter Types

The package provides DB\-agnostic filter conditions:

```
| Type                    | Description                  | SQL Equivalent                    |
|-------------------------|------------------------------|-----------------------------------|
| MatchCondition          | Exact value match            | WHERE field = value               |
| MatchAnyCondition       | Value in set                 | WHERE field IN (...)              |
| MatchExceptCondition    | Value not in set             | WHERE field NOT IN (...)          |
| NumericRangeCondition   | Numeric range                | WHERE field >= min AND field <= max|
| TimeRangeCondition      | Datetime range               | WHERE created_at BETWEEN ...      |
| IsNullCondition         | Field is null                | WHERE field IS NULL               |
| IsEmptyCondition        | Field is empty/null/missing  | WHERE field IS NULL OR field = '' |
| NestedFilterCondition   | Nested filter group          | (A OR B) AND (C OR D)             |
```

Use convenience constructors for cleaner code:

```
// Internal field (top-level in payload)
vectordb.NewMatch("status", "published")

// User-defined field (stored under "custom." prefix)
vectordb.NewUserMatch("category", "research")

// Range conditions with NumericRange/TimeRange structs
vectordb.NewNumericRange("price", vectordb.NumericRange{Gte: &min, Lt: &max})
vectordb.NewTimeRange("created_at", vectordb.TimeRange{AtOrAfter: &start, Before: &end})
```

## Index

- [func Must\(conditions ...FilterCondition\) func\(\*FilterSet\)](<#Must>)
- [func MustNot\(conditions ...FilterCondition\) func\(\*FilterSet\)](<#MustNot>)
- [func Should\(conditions ...FilterCondition\) func\(\*FilterSet\)](<#Should>)
- [type Collection](<#Collection>)
- [type ConditionSet](<#ConditionSet>)
  - [func \(cs \*ConditionSet\) MarshalJSON\(\) \(\[\]byte, error\)](<#ConditionSet.MarshalJSON>)
  - [func \(cs \*ConditionSet\) UnmarshalJSON\(data \[\]byte\) error](<#ConditionSet.UnmarshalJSON>)
- [type EmbeddingInput](<#EmbeddingInput>)
- [type FieldType](<#FieldType>)
- [type FilterCondition](<#FilterCondition>)
- [type FilterSet](<#FilterSet>)
  - [func NewFilterSet\(clauses ...func\(\*FilterSet\)\) \*FilterSet](<#NewFilterSet>)
- [type IsEmptyCondition](<#IsEmptyCondition>)
  - [func NewIsEmpty\(field string\) \*IsEmptyCondition](<#NewIsEmpty>)
  - [func NewUserIsEmpty\(field string\) \*IsEmptyCondition](<#NewUserIsEmpty>)
  - [func \(c \*IsEmptyCondition\) IsFilterCondition\(\)](<#IsEmptyCondition.IsFilterCondition>)
- [type IsNullCondition](<#IsNullCondition>)
  - [func NewIsNull\(field string\) \*IsNullCondition](<#NewIsNull>)
  - [func NewUserIsNull\(field string\) \*IsNullCondition](<#NewUserIsNull>)
  - [func \(c \*IsNullCondition\) IsFilterCondition\(\)](<#IsNullCondition.IsFilterCondition>)
- [type MatchAnyCondition](<#MatchAnyCondition>)
  - [func NewMatchAny\(field string, values ...any\) \*MatchAnyCondition](<#NewMatchAny>)
  - [func NewUserMatchAny\(field string, values ...any\) \*MatchAnyCondition](<#NewUserMatchAny>)
  - [func \(c \*MatchAnyCondition\) IsFilterCondition\(\)](<#MatchAnyCondition.IsFilterCondition>)
- [type MatchCondition](<#MatchCondition>)
  - [func NewMatch\(field string, value any\) \*MatchCondition](<#NewMatch>)
  - [func NewUserMatch\(field string, value any\) \*MatchCondition](<#NewUserMatch>)
  - [func \(c \*MatchCondition\) IsFilterCondition\(\)](<#MatchCondition.IsFilterCondition>)
- [type MatchExceptCondition](<#MatchExceptCondition>)
  - [func NewMatchExcept\(field string, values ...any\) \*MatchExceptCondition](<#NewMatchExcept>)
  - [func NewUserMatchExcept\(field string, values ...any\) \*MatchExceptCondition](<#NewUserMatchExcept>)
  - [func \(c \*MatchExceptCondition\) IsFilterCondition\(\)](<#MatchExceptCondition.IsFilterCondition>)
- [type NestedFilterCondition](<#NestedFilterCondition>)
  - [func \(c \*NestedFilterCondition\) IsFilterCondition\(\)](<#NestedFilterCondition.IsFilterCondition>)
- [type NumericRange](<#NumericRange>)
- [type NumericRangeCondition](<#NumericRangeCondition>)
  - [func NewNumericRange\(field string, r NumericRange\) \*NumericRangeCondition](<#NewNumericRange>)
  - [func NewUserNumericRange\(field string, r NumericRange\) \*NumericRangeCondition](<#NewUserNumericRange>)
  - [func \(c \*NumericRangeCondition\) IsFilterCondition\(\)](<#NumericRangeCondition.IsFilterCondition>)
  - [func \(c \*NumericRangeCondition\) MarshalJSON\(\) \(\[\]byte, error\)](<#NumericRangeCondition.MarshalJSON>)
  - [func \(c \*NumericRangeCondition\) UnmarshalJSON\(data \[\]byte\) error](<#NumericRangeCondition.UnmarshalJSON>)
- [type SearchRequest](<#SearchRequest>)
- [type SearchResult](<#SearchResult>)
- [type Service](<#Service>)
- [type TimeRange](<#TimeRange>)
- [type TimeRangeCondition](<#TimeRangeCondition>)
  - [func NewTimeRange\(field string, t TimeRange\) \*TimeRangeCondition](<#NewTimeRange>)
  - [func NewUserTimeRange\(field string, t TimeRange\) \*TimeRangeCondition](<#NewUserTimeRange>)
  - [func \(c \*TimeRangeCondition\) IsFilterCondition\(\)](<#TimeRangeCondition.IsFilterCondition>)
  - [func \(c TimeRangeCondition\) MarshalJSON\(\) \(\[\]byte, error\)](<#TimeRangeCondition.MarshalJSON>)
  - [func \(c \*TimeRangeCondition\) UnmarshalJSON\(data \[\]byte\) error](<#TimeRangeCondition.UnmarshalJSON>)


<a name="Must"></a>
## func [Must](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/utils.go#L29>)

```go
func Must(conditions ...FilterCondition) func(*FilterSet)
```

Must creates a Must clause \(AND logic\) with the given conditions. All conditions must match for a document to be included.

<a name="MustNot"></a>
## func [MustNot](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/utils.go#L45>)

```go
func MustNot(conditions ...FilterCondition) func(*FilterSet)
```

MustNot creates a MustNot clause \(NOT logic\) with the given conditions. Documents matching any of these conditions are excluded.

<a name="Should"></a>
## func [Should](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/utils.go#L37>)

```go
func Should(conditions ...FilterCondition) func(*FilterSet)
```

Should creates a Should clause \(OR logic\) with the given conditions. At least one condition must match for a document to be included.

<a name="Collection"></a>
## type [Collection](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/types.go#L51-L69>)

Collection contains metadata about a vector collection.

```go
type Collection struct {
    // Name is the unique identifier of the collection
    Name string `json:"name"`

    // Status indicates the operational state (e.g., "Green", "Yellow")
    Status string `json:"status"`

    // VectorSize is the dimension of vectors in this collection
    VectorSize int `json:"vectorSize"`

    // Distance is the similarity metric (e.g., "Cosine", "Dot", "Euclid")
    Distance string `json:"distance"`

    // VectorCount is the number of indexed vectors
    VectorCount uint64 `json:"vectorCount"`

    // PointCount is the number of stored points/documents
    PointCount uint64 `json:"pointCount"`
}
```

<a name="ConditionSet"></a>
## type [ConditionSet](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/filters.go#L48-L50>)

ConditionSet holds a group of conditions for a single clause.

```go
type ConditionSet struct {
    Conditions []FilterCondition `json:"conditions,omitempty"`
}
```

<a name="ConditionSet.MarshalJSON"></a>
### func \(\*ConditionSet\) [MarshalJSON](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/utils.go#L147>)

```go
func (cs *ConditionSet) MarshalJSON() ([]byte, error)
```

MarshalJSON implements custom JSON marshaling for ConditionSet. This is needed because FilterCondition is an interface.

<a name="ConditionSet.UnmarshalJSON"></a>
### func \(\*ConditionSet\) [UnmarshalJSON](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/utils.go#L154>)

```go
func (cs *ConditionSet) UnmarshalJSON(data []byte) error
```

UnmarshalJSON implements custom JSON unmarshaling for ConditionSet. It detects the condition type based on JSON keys and deserializes into the appropriate concrete type \(MatchCondition, NumericRangeCondition, etc.\)

<a name="EmbeddingInput"></a>
## type [EmbeddingInput](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/types.go#L39-L48>)

EmbeddingInput is the input for inserting vectors into a collection.

```go
type EmbeddingInput struct {
    // ID is the unique identifier for this embedding
    ID  string `json:"id"`

    // Vector is the dense embedding representation
    Vector []float32 `json:"vector"`

    // Payload is optional metadata to store with the vector
    Payload map[string]any `json:"payload,omitempty"`
}
```

<a name="FieldType"></a>
## type [FieldType](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/filters.go#L10>)

FieldType indicates whether a field is internal \(system\-managed\) or user\-defined \(stored under a prefix like "custom."\).

```go
type FieldType int
```

<a name="InternalField"></a>

```go
const (
    // InternalField - system-managed fields stored at top-level
    InternalField FieldType = iota
    // UserField - user-defined fields stored under a prefix (e.g., "custom.")
    UserField
)
```

<a name="FilterCondition"></a>
## type [FilterCondition](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/filters.go#L21-L24>)

FilterCondition is the interface all filter conditions must implement. Each database adapter converts these to its native filter format.

```go
type FilterCondition interface {
    // isFilterCondition is a marker method to ensure type safety
    IsFilterCondition()
}
```

<a name="FilterSet"></a>
## type [FilterSet](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/filters.go#L38-L45>)

FilterSet supports Must \(AND\), Should \(OR\), and MustNot \(NOT\) clauses. Use with SearchRequest.Filters to filter search results.

Example:

```
filters := &FilterSet{
    Must: &ConditionSet{
        Conditions: []FilterCondition{
            &MatchCondition{Field: "city", Value: "London"},
        },
    },
}
```

```go
type FilterSet struct {
    // Must: All conditions must match (AND)
    Must *ConditionSet `json:"must,omitempty"`
    // Should: At least one condition must match (OR)
    Should *ConditionSet `json:"should,omitempty"`
    // MustNot: None of the conditions should match (NOT)
    MustNot *ConditionSet `json:"mustNot,omitempty"`
}
```

<a name="NewFilterSet"></a>
### func [NewFilterSet](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/utils.go#L19>)

```go
func NewFilterSet(clauses ...func(*FilterSet)) *FilterSet
```

NewFilterSet creates a FilterSet with the given clauses. Use with Must\(\), Should\(\), and MustNot\(\) helpers.

Example:

```
vectordb.NewFilterSet(
    vectordb.Must(vectordb.NewMatch("status", "published")),
    vectordb.Should(vectordb.NewMatch("tag", "ml"), vectordb.NewMatch("tag", "ai")),
)
```

<a name="IsEmptyCondition"></a>
## type [IsEmptyCondition](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/filters.go#L217-L220>)

IsEmptyCondition checks if a field is empty \(doesn't exist, null, or \[\]\). SQL equivalent: WHERE field IS NULL OR field = ” OR field = \[\]

```go
type IsEmptyCondition struct {
    Field     string    `json:"field"`
    FieldType FieldType `json:"-"`
}
```

<a name="NewIsEmpty"></a>
### func [NewIsEmpty](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/utils.go#L134>)

```go
func NewIsEmpty(field string) *IsEmptyCondition
```

NewIsEmpty creates an IS EMPTY condition for internal fields.

<a name="NewUserIsEmpty"></a>
### func [NewUserIsEmpty](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/utils.go#L139>)

```go
func NewUserIsEmpty(field string) *IsEmptyCondition
```

NewUserIsEmpty creates an IS EMPTY condition for user\-defined fields.

<a name="IsEmptyCondition.IsFilterCondition"></a>
### func \(\*IsEmptyCondition\) [IsFilterCondition](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/filters.go#L222>)

```go
func (c *IsEmptyCondition) IsFilterCondition()
```



<a name="IsNullCondition"></a>
## type [IsNullCondition](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/filters.go#L208-L211>)

IsNullCondition checks if a field has a NULL value. SQL equivalent: WHERE field IS NULL

```go
type IsNullCondition struct {
    Field     string    `json:"field"`
    FieldType FieldType `json:"-"`
}
```

<a name="NewIsNull"></a>
### func [NewIsNull](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/utils.go#L124>)

```go
func NewIsNull(field string) *IsNullCondition
```

NewIsNull creates an IS NULL condition for internal fields.

<a name="NewUserIsNull"></a>
### func [NewUserIsNull](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/utils.go#L129>)

```go
func NewUserIsNull(field string) *IsNullCondition
```

NewUserIsNull creates an IS NULL condition for user\-defined fields.

<a name="IsNullCondition.IsFilterCondition"></a>
### func \(\*IsNullCondition\) [IsFilterCondition](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/filters.go#L213>)

```go
func (c *IsNullCondition) IsFilterCondition()
```



<a name="MatchAnyCondition"></a>
## type [MatchAnyCondition](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/filters.go#L66-L70>)

MatchAnyCondition matches if value is one of the given values \(IN operator\). SQL equivalent: WHERE field IN \(value1, value2, ...\)

```go
type MatchAnyCondition struct {
    Field     string    `json:"field"`
    Values    []any     `json:"anyOf"`
    FieldType FieldType `json:"-"`
}
```

<a name="NewMatchAny"></a>
### func [NewMatchAny](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/utils.go#L64>)

```go
func NewMatchAny(field string, values ...any) *MatchAnyCondition
```

NewMatchAny creates an IN condition for internal fields.

<a name="NewUserMatchAny"></a>
### func [NewUserMatchAny](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/utils.go#L70>)

```go
func NewUserMatchAny(field string, values ...any) *MatchAnyCondition
```

NewUserMatchAny creates an IN condition for user\-defined fields.

<a name="MatchAnyCondition.IsFilterCondition"></a>
### func \(\*MatchAnyCondition\) [IsFilterCondition](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/filters.go#L72>)

```go
func (c *MatchAnyCondition) IsFilterCondition()
```



<a name="MatchCondition"></a>
## type [MatchCondition](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/filters.go#L56-L60>)

MatchCondition represents an exact match filter \(WHERE field = value\). Supports string, bool, and int64 values.

```go
type MatchCondition struct {
    Field     string    `json:"field"`
    Value     any       `json:"equalTo"`
    FieldType FieldType `json:"-"`
}
```

<a name="NewMatch"></a>
### func [NewMatch](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/utils.go#L54>)

```go
func NewMatch(field string, value any) *MatchCondition
```

NewMatch creates a match condition for internal fields.

<a name="NewUserMatch"></a>
### func [NewUserMatch](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/utils.go#L59>)

```go
func NewUserMatch(field string, value any) *MatchCondition
```

NewUserMatch creates a match condition for user\-defined fields.

<a name="MatchCondition.IsFilterCondition"></a>
### func \(\*MatchCondition\) [IsFilterCondition](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/filters.go#L62>)

```go
func (c *MatchCondition) IsFilterCondition()
```



<a name="MatchExceptCondition"></a>
## type [MatchExceptCondition](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/filters.go#L76-L80>)

MatchExceptCondition matches if value is NOT one of the given values \(NOT IN\). SQL equivalent: WHERE field NOT IN \(value1, value2, ...\)

```go
type MatchExceptCondition struct {
    Field     string    `json:"field"`
    Values    []any     `json:"noneOf"`
    FieldType FieldType `json:"-"`
}
```

<a name="NewMatchExcept"></a>
### func [NewMatchExcept](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/utils.go#L76>)

```go
func NewMatchExcept(field string, values ...any) *MatchExceptCondition
```

NewMatchExcept creates a NOT IN condition for internal fields.

<a name="NewUserMatchExcept"></a>
### func [NewUserMatchExcept](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/utils.go#L82>)

```go
func NewUserMatchExcept(field string, values ...any) *MatchExceptCondition
```

NewUserMatchExcept creates a NOT IN condition for user\-defined fields.

<a name="MatchExceptCondition.IsFilterCondition"></a>
### func \(\*MatchExceptCondition\) [IsFilterCondition](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/filters.go#L82>)

```go
func (c *MatchExceptCondition) IsFilterCondition()
```



<a name="NestedFilterCondition"></a>
## type [NestedFilterCondition](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/filters.go#L266-L268>)

NestedFilterCondition allows a FilterSet to be used as a condition. This enables complex recursive filters like \(A AND B\) OR \(C AND D\).

Example \- \(A OR B\) AND \(C OR D\):

```
filters := &FilterSet{
    Must: &ConditionSet{
        Conditions: []FilterCondition{
            &NestedFilterCondition{
                Filter: &FilterSet{
                    Should: &ConditionSet{Conditions: []FilterCondition{A, B}},
                },
            },
            &NestedFilterCondition{
                Filter: &FilterSet{
                    Should: &ConditionSet{Conditions: []FilterCondition{C, D}},
                },
            },
        },
    },
}
```

Example \- \(A AND B\) OR \(C AND D\):

```
filters := &FilterSet{
    Should: &ConditionSet{
        Conditions: []FilterCondition{
            &NestedFilterCondition{
                Filter: &FilterSet{
                    Must: &ConditionSet{Conditions: []FilterCondition{A, B}},
                },
            },
            &NestedFilterCondition{
                Filter: &FilterSet{
                    Must: &ConditionSet{Conditions: []FilterCondition{C, D}},
                },
            },
        },
    },
}
```

```go
type NestedFilterCondition struct {
    Filter *FilterSet `json:"filter"`
}
```

<a name="NestedFilterCondition.IsFilterCondition"></a>
### func \(\*NestedFilterCondition\) [IsFilterCondition](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/filters.go#L270>)

```go
func (c *NestedFilterCondition) IsFilterCondition()
```



<a name="NumericRange"></a>
## type [NumericRange](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/filters.go#L88-L93>)

NumericRange defines bounds for numeric filtering. Used with NewNumericRange for cleaner constructor calls.

```go
type NumericRange struct {
    Gt  *float64 `json:"greaterThan,omitempty"`          // GreaterThan (exclusive)
    Gte *float64 `json:"greaterThanOrEqualTo,omitempty"` // GreaterThanOrEqualTo (inclusive)
    Lt  *float64 `json:"lessThan,omitempty"`             // LessThan (exclusive)
    Lte *float64 `json:"lessThanOrEqualTo,omitempty"`    // LessThanOrEqualTo (inclusive)
}
```

<a name="NumericRangeCondition"></a>
## type [NumericRangeCondition](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/filters.go#L108-L112>)

NumericRangeCondition filters by numeric range. SQL equivalent: WHERE field \>= min AND field \<= max

```go
type NumericRangeCondition struct {
    Field     string       `json:"field"`
    Range     NumericRange `json:"-"`
    FieldType FieldType    `json:"-"`
}
```

<a name="NewNumericRange"></a>
### func [NewNumericRange](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/utils.go#L88>)

```go
func NewNumericRange(field string, r NumericRange) *NumericRangeCondition
```

NewNumericRange creates a numeric range condition for internal fields.

<a name="NewUserNumericRange"></a>
### func [NewUserNumericRange](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/utils.go#L97>)

```go
func NewUserNumericRange(field string, r NumericRange) *NumericRangeCondition
```

NewUserNumericRange creates a numeric range condition for user\-defined fields.

<a name="NumericRangeCondition.IsFilterCondition"></a>
### func \(\*NumericRangeCondition\) [IsFilterCondition](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/filters.go#L114>)

```go
func (c *NumericRangeCondition) IsFilterCondition()
```



<a name="NumericRangeCondition.MarshalJSON"></a>
### func \(\*NumericRangeCondition\) [MarshalJSON](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/filters.go#L116>)

```go
func (c *NumericRangeCondition) MarshalJSON() ([]byte, error)
```



<a name="NumericRangeCondition.UnmarshalJSON"></a>
### func \(\*NumericRangeCondition\) [UnmarshalJSON](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/filters.go#L133>)

```go
func (c *NumericRangeCondition) UnmarshalJSON(data []byte) error
```



<a name="SearchRequest"></a>
## type [SearchRequest](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/types.go#L5-L17>)

SearchRequest represents a single similarity search query. Use with Service.Search\(\) for single or batch queries.

```go
type SearchRequest struct {
    // CollectionName is the target collection to search in
    CollectionName string `json:"collectionName"`

    // Vector is the query embedding to find similar vectors for
    Vector []float32 `json:"vector"`

    // TopK is the maximum number of results to return
    TopK int `json:"maxResults"`

    // Filters is optional metadata filtering (AND/OR/NOT logic)
    Filters []*FilterSet `json:"filters,omitempty"`
}
```

<a name="SearchResult"></a>
## type [SearchResult](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/types.go#L21-L36>)

SearchResult represents a single search result with its similarity score. This is database\-agnostic—payload is converted to map\[string\]any.

```go
type SearchResult struct {
    // ID is the unique identifier of the matched point
    ID  string `json:"id"`

    // Score is the similarity score (higher = more similar for cosine)
    Score float32 `json:"score"`

    // Payload contains the metadata stored with the vector
    Payload map[string]any `json:"payload"`

    // Vector is the stored embedding (only populated if requested)
    Vector []float32 `json:"vector,omitempty"`

    // CollectionName identifies which collection this result came from
    CollectionName string `json:"collectionName,omitempty"`
}
```

<a name="Service"></a>
## type [Service](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/interface.go#L19-L60>)

Service is the common interface for all vector databases. It provides a database\-agnostic abstraction for vector similarity search, allowing applications to switch between different vector databases \(Qdrant, pgVector, etc.\) without changing application code.

Example usage:

```
func NewSearchService(db vectordb.Service) *SearchService {
    return &SearchService{db: db}
}

// Works with any implementation:
// - vectordb.NewQdrantAdapter(qdrantClient)
// - vectordb.NewPgVectorAdapter(pgVectorClient)
```

```go
type Service interface {
    // Search performs similarity search across one or more requests.
    // Each request can target a different collection with different filters.
    // Returns:
    //   - results: slice of result slices—one []SearchResult per request
    //   - errs: per-request errors (errs[i] corresponds to requests[i])
    //   - err: systemic error (context cancelled, etc.)
    //
    // Example:
    //   results, errs, err := db.Search(ctx,
    //       SearchRequest{CollectionName: "docs", Vector: vec1, TopK: 10},
    //       SearchRequest{CollectionName: "docs", Vector: vec2, TopK: 5, Filters: filters},
    //   )
    //   if err != nil {
    //       return err // systemic failure
    //   }
    //   for i, res := range results {
    //       if errs[i] != nil {
    //           log.Printf("request %d failed: %v", i, errs[i])
    //           continue
    //       }
    //       // use res...
    //   }
    Search(ctx context.Context, requests ...SearchRequest) ([][]SearchResult, []error, error)

    // Insert adds embeddings to a collection.
    // Uses batch processing internally for efficiency.
    Insert(ctx context.Context, collectionName string, inputs []EmbeddingInput) error

    // Delete removes points by their IDs from a collection.
    Delete(ctx context.Context, collection string, ids []string) error

    // EnsureCollection creates a collection if it doesn't exist.
    // Safe to call multiple times—no-op if collection already exists.
    EnsureCollection(ctx context.Context, name string, vectorSize uint64) error

    // GetCollection retrieves metadata about a collection.
    GetCollection(ctx context.Context, name string) (*Collection, error)

    // ListCollections returns names of all collections.
    ListCollections(ctx context.Context) ([]string, error)
}
```

<a name="TimeRange"></a>
## type [TimeRange](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/filters.go#L97-L102>)

TimeRange defines bounds for time filtering. Used with NewTimeRange for cleaner constructor calls.

```go
type TimeRange struct {
    Gt  *time.Time `json:"after,omitempty"`      // After (exclusive)
    Gte *time.Time `json:"atOrAfter,omitempty"`  // AtOrAfter (inclusive)
    Lt  *time.Time `json:"before,omitempty"`     // Before (exclusive)
    Lte *time.Time `json:"atOrBefore,omitempty"` // AtOrBefore (inclusive)
}
```

<a name="TimeRangeCondition"></a>
## type [TimeRangeCondition](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/filters.go#L157-L161>)

TimeRangeCondition filters by datetime range. SQL equivalent: WHERE created\_at \>= '2024\-01\-01' AND created\_at \< '2025\-01\-01'

```go
type TimeRangeCondition struct {
    Field     string    `json:"field"`
    Range     TimeRange `json:"-"`
    FieldType FieldType `json:"-"`
}
```

<a name="NewTimeRange"></a>
### func [NewTimeRange](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/utils.go#L106>)

```go
func NewTimeRange(field string, t TimeRange) *TimeRangeCondition
```

NewTimeRange creates a time range condition for internal fields.

<a name="NewUserTimeRange"></a>
### func [NewUserTimeRange](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/utils.go#L115>)

```go
func NewUserTimeRange(field string, t TimeRange) *TimeRangeCondition
```

NewUserTimeRange creates a time range condition for user\-defined fields.

<a name="TimeRangeCondition.IsFilterCondition"></a>
### func \(\*TimeRangeCondition\) [IsFilterCondition](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/filters.go#L163>)

```go
func (c *TimeRangeCondition) IsFilterCondition()
```



<a name="TimeRangeCondition.MarshalJSON"></a>
### func \(TimeRangeCondition\) [MarshalJSON](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/filters.go#L165>)

```go
func (c TimeRangeCondition) MarshalJSON() ([]byte, error)
```



<a name="TimeRangeCondition.UnmarshalJSON"></a>
### func \(\*TimeRangeCondition\) [UnmarshalJSON](<https://github.com/Aleph-Alpha/std/blob/main/v1/vectordb/filters.go#L182>)

```go
func (c *TimeRangeCondition) UnmarshalJSON(data []byte) error
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
