<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# qdrant

```go
import "github.com/Aleph-Alpha/std/v1/qdrant"
```

Package qdrant provides a modular, dependency\-injected client for the Qdrant vector database.

The qdrant package is designed to simplify interaction with Qdrant in Go applications, offering a clean, testable abstraction layer for common vector database operations such as collection management, embedding insertion, similarity search, and deletion. It integrates seamlessly with the fx dependency injection framework and supports builder\-style configuration.

Core Features:

- Managed Qdrant client lifecycle with Fx integration
- Config struct supporting environment and YAML loading
- Automatic health checks on client initialization
- Safe, batched insertion of embeddings with configurable batch size
- Vector similarity search with abstracted SearchResult interface
- Type\-safe collection creation and existence checks
- Support for payload metadata and optional vector retrieval
- Extensible abstraction layer for alternate vector stores \(e.g. pgVector\)

Basic Usage:

```
import "github.com/Aleph-Alpha/std/v1/qdrant"

// Create a new client
client, err := qdrant.NewQdrantClient(qdrant.QdrantParams{
	Config: &qdrant.Config{
		Endpoint: "localhost:6334",
		ApiKey:   "",
	},
})
if err != nil {
	log.Fatal(err)
}

collectionName := "documents"

// Insert single embedding
input := qdrant.EmbeddingInput{
	ID:     "doc_1",
	Vector: []float32{0.12, 0.43, 0.85},
	Meta:   map[string]any{"title": "My Document"},
}
if err := client.Insert(ctx, collectionName, input); err != nil {
	log.Fatal(err)
}

// Batch insert embeddings
batch := []qdrant.EmbeddingInput{input1, input2, input3}
if err := client.BatchInsert(ctx, collectionName, batch); err != nil {
	log.Fatal(err)
}

// Perform similarity search
results, err := client.Search(ctx, qdrant.SearchRequest{
	CollectionName: collectionName,
	Vector:         queryVector,
	TopK:           5,
})
for _, res := range results[0] {
	fmt.Printf("ID=%s Score=%.4f\n", res.GetID(), res.GetScore())
}
```

FX Module Integration:

The package exposes an Fx module for automatic dependency injection:

```
app := fx.New(
	qdrant.FXModule,
	// other modules...
)
app.Run()
```

Abstractions:

The package defines a lightweight SearchResultInterface that encapsulates search results via methods such as GetID\(\), GetScore\(\), GetMeta\(\), and GetCollectionName\(\). The underlying concrete type remains SearchResult, allowing both strong typing internally and loose coupling externally.

Example:

```
type SearchResultInterface interface {
	GetID() string
	GetScore() float32
	GetMeta() map[string]*qdrant.Value
	GetCollectionName() string
}

type SearchResult struct { /* implements SearchResultInterface */ }

// Function signature:
func (c *QdrantClient) Search(ctx context.Context, vector []float32, topK int) ([]SearchResultInterface, error)
```

### Filtering

The package provides a comprehensive, type\-safe filtering system for vector searches. Filters support boolean logic \(AND, OR, NOT\) and various condition types.

Filter Structure:

```
type FilterSet struct {
    Must    *ConditionSet  // AND - all conditions must match
    Should  *ConditionSet  // OR - at least one condition must match
    MustNot *ConditionSet  // NOT - none of the conditions should match
}
```

Condition Types:

- TextCondition: Exact string match
- BoolCondition: Exact boolean match
- IntCondition: Exact integer match
- TextAnyCondition: String IN operator \(match any of values\)
- IntAnyCondition: Integer IN operator
- TextExceptCondition: String NOT IN operator
- IntExceptCondition: Integer NOT IN operator
- TimeRangeCondition: DateTime range filter \(gte, lte, gt, lt\)
- NumericRangeCondition: Numeric range filter
- IsNullCondition: Check if field is null
- IsEmptyCondition: Check if field is empty, null, or missing

Field Types \(Internal vs User\):

The package distinguishes between system\-managed and user\-defined metadata:

```
const (
    InternalField FieldType = iota  // Top-level: "search_store_id"
    UserField                        // Nested: "custom.document_id"
)
```

User fields are automatically prefixed with "custom." when querying Qdrant.

Basic Filter Example:

```
// Filter: city = "London" AND active = true
filters := &qdrant.FilterSet{
    Must: &qdrant.ConditionSet{
        Conditions: []qdrant.FilterCondition{
            qdrant.TextCondition{Key: "city", Value: "London"},
            qdrant.BoolCondition{Key: "active", Value: true},
        },
    },
}

results, err := client.Search(ctx, qdrant.SearchRequest{
    CollectionName: "documents",
    Vector:         queryVector,
    TopK:           10,
    Filters:        filters,
})
```

OR Conditions \(Should\):

```
// Filter: city = "London" OR city = "Berlin"
filters := &qdrant.FilterSet{
    Should: &qdrant.ConditionSet{
        Conditions: []qdrant.FilterCondition{
            qdrant.TextCondition{Key: "city", Value: "London"},
            qdrant.TextCondition{Key: "city", Value: "Berlin"},
        },
    },
}
```

IN Operator \(MatchAny\):

```
// Filter: city IN ["London", "Berlin", "Paris"]
filters := &qdrant.FilterSet{
    Must: &qdrant.ConditionSet{
        Conditions: []qdrant.FilterCondition{
            qdrant.TextAnyCondition{
                Key:    "city",
                Values: []string{"London", "Berlin", "Paris"},
            },
        },
    },
}
```

Time Range Filter:

```
now := time.Now()
yesterday := now.Add(-24 * time.Hour)

filters := &qdrant.FilterSet{
    Must: &qdrant.ConditionSet{
        Conditions: []qdrant.FilterCondition{
            qdrant.TimeRangeCondition{
                Key: "created_at",
                Value: qdrant.TimeRange{
                    Gte: &yesterday,
                    Lt:  &now,
                },
            },
        },
    },
}
```

Complex Filter \(Combined Clauses\):

```
// Filter: (status = "published") AND (category = "tech" OR "science") AND NOT (deleted = true)
filters := &qdrant.FilterSet{
    Must: &qdrant.ConditionSet{
        Conditions: []qdrant.FilterCondition{
            qdrant.TextCondition{Key: "status", Value: "published"},
        },
    },
    Should: &qdrant.ConditionSet{
        Conditions: []qdrant.FilterCondition{
            qdrant.TextCondition{Key: "category", Value: "tech", FieldType: qdrant.UserField},
            qdrant.TextCondition{Key: "category", Value: "science", FieldType: qdrant.UserField},
        },
    },
    MustNot: &qdrant.ConditionSet{
        Conditions: []qdrant.FilterCondition{
            qdrant.BoolCondition{Key: "deleted", Value: true},
        },
    },
}
```

UUID Filtering:

UUIDs are filtered as strings using TextCondition:

```
filters := &qdrant.FilterSet{
    Must: &qdrant.ConditionSet{
        Conditions: []qdrant.FilterCondition{
            qdrant.TextCondition{
                Key:       "document_id",
                Value:     "f47ac10b-58cc-4372-a567-0e02b2c3d479",
                FieldType: qdrant.UserField,
            },
        },
    },
}
```

Payload Structure Helper:

The BuildPayload function creates properly structured payloads that separate internal and user fields:

```
payload := qdrant.BuildPayload(
    map[string]any{"search_store_id": "store-123"},  // Internal (top-level)
    map[string]any{"document_id": "doc-456"},        // User (under "custom.")
)

// Result:
// {
//     "search_store_id": "store-123",
//     "custom": {
//         "document_id": "doc-456"
//     }
// }
```

This structure ensures user\-defined filter indexes are created at the correct path \(custom.field\_name\).

Configuration:

Qdrant can be configured via environment variables or YAML:

```
QDRANT_ENDPOINT=http://localhost:6334
QDRANT_API_KEY=your-api-key
```

Performance Considerations:

The BatchInsert method automatically splits large embedding inserts into smaller upserts \(default batch size = 500\). This minimizes memory usage and avoids timeouts when ingesting large datasets.

Thread Safety:

All exported methods on QdrantClient are safe for concurrent use by multiple goroutines.

Testing:

For testing and mocking, application code should depend on the public interface types \(e.g., SearchResultInterface, EmbeddingInput\) instead of concrete Qdrant structs. This allows replacing the QdrantClient with in\-memory or mock implementations in tests.

Example Mock:

```
type MockResult struct {
	id    string
	score float32
	meta  map[string]any
}
func (m MockResult) GetID() string           { return m.id }
func (m MockResult) GetScore() float32       { return m.score }
func (m MockResult) GetMeta() map[string]any { return m.meta }
```

Package Layout:

```
qdrant/
├── client.go        // Qdrant client implementation
├── operations.go    // CRUD operations (Insert, Search, Delete, etc.)
├── filters.go       // Type-safe filtering system
├── utils.go         // Shared types and interfaces
├── configs.go       // Configuration struct and builder methods
└── fx_module.go     // Fx dependency injection module
```

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [func BuildPayload\(internal map\[string\]any, user map\[string\]any\) map\[string\]any](<#BuildPayload>)
- [func RegisterQdrantLifecycle\(lc fx.Lifecycle, client \*QdrantClient\)](<#RegisterQdrantLifecycle>)
- [type BoolCondition](<#BoolCondition>)
- [type Collection](<#Collection>)
- [type ConditionSet](<#ConditionSet>)
- [type Config](<#Config>)
  - [func DefaultConfig\(\) \*Config](<#DefaultConfig>)
  - [func FromEndpoint\(url string\) \*Config](<#FromEndpoint>)
  - [func \(c \*Config\) WithApiKey\(key string\) \*Config](<#Config.WithApiKey>)
  - [func \(c \*Config\) WithCompatibilityCheck\(enabled bool\) \*Config](<#Config.WithCompatibilityCheck>)
  - [func \(c \*Config\) WithCompression\(enabled bool\) \*Config](<#Config.WithCompression>)
  - [func \(c \*Config\) WithConnectTimeout\(d time.Duration\) \*Config](<#Config.WithConnectTimeout>)
  - [func \(c \*Config\) WithKeepAlive\(enabled bool\) \*Config](<#Config.WithKeepAlive>)
  - [func \(c \*Config\) WithTimeout\(d time.Duration\) \*Config](<#Config.WithTimeout>)
- [type Embedding](<#Embedding>)
  - [func NewEmbedding\(input EmbeddingInput\) Embedding](<#NewEmbedding>)
- [type EmbeddingInput](<#EmbeddingInput>)
- [type FieldType](<#FieldType>)
- [type FilterCondition](<#FilterCondition>)
- [type FilterSet](<#FilterSet>)
- [type IntAnyCondition](<#IntAnyCondition>)
- [type IntCondition](<#IntCondition>)
- [type IntExceptCondition](<#IntExceptCondition>)
- [type IsEmptyCondition](<#IsEmptyCondition>)
  - [func \(c IsEmptyCondition\) ToQdrantCondition\(\) \[\]\*qdrant.Condition](<#IsEmptyCondition.ToQdrantCondition>)
- [type IsNullCondition](<#IsNullCondition>)
  - [func \(c IsNullCondition\) ToQdrantCondition\(\) \[\]\*qdrant.Condition](<#IsNullCondition.ToQdrantCondition>)
- [type MatchAnyCondition](<#MatchAnyCondition>)
  - [func \(c MatchAnyCondition\[T\]\) ToQdrantCondition\(\) \[\]\*qdrant.Condition](<#MatchAnyCondition[T].ToQdrantCondition>)
- [type MatchCondition](<#MatchCondition>)
  - [func \(c MatchCondition\[T\]\) ToQdrantCondition\(\) \[\]\*qdrant.Condition](<#MatchCondition[T].ToQdrantCondition>)
- [type MatchExceptCondition](<#MatchExceptCondition>)
  - [func \(c MatchExceptCondition\[T\]\) ToQdrantCondition\(\) \[\]\*qdrant.Condition](<#MatchExceptCondition[T].ToQdrantCondition>)
- [type NumericRange](<#NumericRange>)
- [type NumericRangeCondition](<#NumericRangeCondition>)
  - [func \(c NumericRangeCondition\) MarshalJSON\(\) \(\[\]byte, error\)](<#NumericRangeCondition.MarshalJSON>)
  - [func \(c NumericRangeCondition\) ToQdrantCondition\(\) \[\]\*qdrant.Condition](<#NumericRangeCondition.ToQdrantCondition>)
  - [func \(c \*NumericRangeCondition\) UnmarshalJSON\(data \[\]byte\) error](<#NumericRangeCondition.UnmarshalJSON>)
- [type QdrantClient](<#QdrantClient>)
  - [func NewQdrantClient\(p QdrantParams\) \(\*QdrantClient, error\)](<#NewQdrantClient>)
  - [func \(c \*QdrantClient\) BatchInsert\(ctx context.Context, collectionName string, inputs \[\]EmbeddingInput\) error](<#QdrantClient.BatchInsert>)
  - [func \(c \*QdrantClient\) Close\(\) error](<#QdrantClient.Close>)
  - [func \(c \*QdrantClient\) Delete\(ctx context.Context, collectionName string, ids \[\]string\) error](<#QdrantClient.Delete>)
  - [func \(c \*QdrantClient\) EnsureCollection\(ctx context.Context, name string\) error](<#QdrantClient.EnsureCollection>)
  - [func \(c \*QdrantClient\) GetCollection\(ctx context.Context, name string\) \(\*Collection, error\)](<#QdrantClient.GetCollection>)
  - [func \(c \*QdrantClient\) Insert\(ctx context.Context, collectionName string, input EmbeddingInput\) error](<#QdrantClient.Insert>)
  - [func \(c \*QdrantClient\) ListCollections\(ctx context.Context\) \(\[\]string, error\)](<#QdrantClient.ListCollections>)
  - [func \(c \*QdrantClient\) Search\(ctx context.Context, requests ...SearchRequest\) \(\[\]\[\]SearchResultInterface, error\)](<#QdrantClient.Search>)
- [type QdrantParams](<#QdrantParams>)
- [type SearchRequest](<#SearchRequest>)
- [type SearchResult](<#SearchResult>)
  - [func \(r SearchResult\) GetCollectionName\(\) string](<#SearchResult.GetCollectionName>)
  - [func \(r SearchResult\) GetID\(\) string](<#SearchResult.GetID>)
  - [func \(r SearchResult\) GetMeta\(\) map\[string\]\*qdrant.Value](<#SearchResult.GetMeta>)
  - [func \(r SearchResult\) GetScore\(\) float32](<#SearchResult.GetScore>)
  - [func \(r SearchResult\) GetVector\(\) \[\]float32](<#SearchResult.GetVector>)
  - [func \(r SearchResult\) HasVector\(\) bool](<#SearchResult.HasVector>)
- [type SearchResultInterface](<#SearchResultInterface>)
- [type TextAnyCondition](<#TextAnyCondition>)
- [type TextCondition](<#TextCondition>)
- [type TextExceptCondition](<#TextExceptCondition>)
- [type TimeRange](<#TimeRange>)
- [type TimeRangeCondition](<#TimeRangeCondition>)
  - [func \(c TimeRangeCondition\) MarshalJSON\(\) \(\[\]byte, error\)](<#TimeRangeCondition.MarshalJSON>)
  - [func \(c TimeRangeCondition\) ToQdrantCondition\(\) \[\]\*qdrant.Condition](<#TimeRangeCondition.ToQdrantCondition>)
  - [func \(c \*TimeRangeCondition\) UnmarshalJSON\(data \[\]byte\) error](<#TimeRangeCondition.UnmarshalJSON>)


## Constants

<a name="UserPayloadPrefix"></a>UserPayloadPrefix is the prefix for user\-defined metadata fields

```go
const UserPayloadPrefix = "custom"
```

## Variables

<a name="FXModule"></a>FXModule defines the Fx module for the Qdrant client.

This module integrates the Qdrant client into an Fx\-based application by providing the client factory and registering its lifecycle hooks.

The module:

1. Provides the NewQdrantClient factory function to the dependency injection container, making the client available to other components.
2. Provides the NewEmbeddingsStore function, which wraps the client into a higher\-level abstraction.
3. Invokes RegisterQdrantLifecycle to handle startup/shutdown of the client.

Usage:

```
app := fx.New(
    qdrant.FXModule,
    // other modules...
)
```

Dependencies required by this module: \- A qdrant.Config instance must be available in the dependency injection container.

```go
var FXModule = fx.Module("qdrant",
    fx.Provide(
        NewQdrantClient,
    ),
    fx.Invoke(RegisterQdrantLifecycle),
)
```

<a name="BuildPayload"></a>
## func [BuildPayload](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/filters.go#L383>)

```go
func BuildPayload(internal map[string]any, user map[string]any) map[string]any
```

BuildPayload creates a Qdrant payload with separated internal and user fields. Internal fields are stored at the top level, while user fields are stored under the "custom" prefix. If internal contains a "custom" key, it will be overwritten by the user fields map.

<a name="RegisterQdrantLifecycle"></a>
## func [RegisterQdrantLifecycle](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/fx_module.go#L54>)

```go
func RegisterQdrantLifecycle(lc fx.Lifecycle, client *QdrantClient)
```

RegisterQdrantLifecycle handles startup/shutdown of the Qdrant client. It ensures proper resource cleanup and logging.

OnStart:

- Performs a Qdrant health check to verify connectivity.
- Logs a success message once the client is ready.

OnStop:

- Ensures the Qdrant client is closed exactly once.
- Logs a shutdown message.

<a name="BoolCondition"></a>
## type [BoolCondition](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/filters.go#L122>)



```go
type BoolCondition = MatchCondition[bool] // Exact boolean match
```

<a name="Collection"></a>
## type [Collection](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/utils.go#L89-L96>)

Collection ────────────────────────────────────────────────────────────── Collection ──────────────────────────────────────────────────────────────

Collection represents a high\-level, decoupled view of a Qdrant collection.

It provides essential metadata about a vector collection without exposing Qdrant SDK types, allowing the application layer to remain independent of the underlying database implementation.

Fields:

- Name — The unique name of the collection.
- Status — Current operational state \(e.g., "Green", "Yellow"\).
- VectorSize — The dimension of stored vectors \(e.g., 1536\).
- Distance — The similarity metric used \("Cosine", "Dot", "Euclid"\).
- Vectors — Total number of stored vectors in the collection.
- Points — Total number of indexed points/documents in the collection.

This struct serves as an abstraction layer between Qdrant's low\-level protobuf models and the higher\-level application logic.

```go
type Collection struct {
    Name       string
    Status     string
    VectorSize int
    Distance   string
    Vectors    uint64
    Points     uint64
}
```

<a name="ConditionSet"></a>
## type [ConditionSet](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/filters.go#L244-L246>)

ConditionSet holds conditions for a single clause

```go
type ConditionSet struct {
    Conditions []FilterCondition `json:"conditions,omitempty"`
}
```

<a name="Config"></a>
## type [Config](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/configs.go#L24-L48>)

Config holds connection and behavior settings for the Qdrant client.

It is intentionally minimal, readable, and easy to override from environment variables, YAML, or programmatically via helper methods.

Example \(programmatic\):

```
cfg := qdrant.DefaultConfig()
cfg.Endpoint = "http://localhost:6334"
cfg.ApiKey = os.Getenv("QDRANT_API_KEY")
cfg.Timeout = 10 * time.Second
```

Example \(builder style\):

```
cfg := qdrant.FromEndpoint("http://localhost:6334").
    WithApiKey(os.Getenv("QDRANT_API_KEY")).
    WithTimeout(10 * time.Second)
```

```go
type Config struct {
    // Hostname of the Qdrant server, e.g. "localhost".
    Endpoint string `yaml:"endpoint" env:"QDRANT_ENDPOINT"`

    // gRPC port of the Qdrant server. Defaults to 6334.
    Port int `yaml:"port" env:"QDRANT_PORT"`

    // Optional authentication token for secured deployments.
    ApiKey string `yaml:"api_key" env:"QDRANT_API_KEY"`

    // Maximum request duration before timing out.
    Timeout time.Duration `yaml:"timeout" env:"QDRANT_TIMEOUT"`

    // Connection establishment timeout.
    ConnectTimeout time.Duration `yaml:"connect_timeout" env:"QDRANT_CONNECT_TIMEOUT"`

    // Whether to keep idle connections open for reuse.
    KeepAlive bool `yaml:"keep_alive" env:"QDRANT_KEEP_ALIVE"`

    // Enable gzip compression for requests.
    Compression bool `yaml:"compression" env:"QDRANT_COMPRESSION"`

    // Whether to perform version compatibility checks between client and server.
    CheckCompatibility bool `yaml:"check_compatibility" env:"QDRANT_CHECK_COMPATIBILITY"`
}
```

<a name="DefaultConfig"></a>
### func [DefaultConfig](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/configs.go#L51>)

```go
func DefaultConfig() *Config
```

DefaultConfig provides sensible defaults for most use cases.

<a name="FromEndpoint"></a>
### func [FromEndpoint](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/configs.go#L64>)

```go
func FromEndpoint(url string) *Config
```

FromEndpoint returns a default config pre\-filled with a specific endpoint.

<a name="Config.WithApiKey"></a>
### func \(\*Config\) [WithApiKey](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/configs.go#L71>)

```go
func (c *Config) WithApiKey(key string) *Config
```

Builder\-style helpers \(optional, ergonomic\)

<a name="Config.WithCompatibilityCheck"></a>
### func \(\*Config\) [WithCompatibilityCheck](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/configs.go#L96>)

```go
func (c *Config) WithCompatibilityCheck(enabled bool) *Config
```



<a name="Config.WithCompression"></a>
### func \(\*Config\) [WithCompression](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/configs.go#L86>)

```go
func (c *Config) WithCompression(enabled bool) *Config
```



<a name="Config.WithConnectTimeout"></a>
### func \(\*Config\) [WithConnectTimeout](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/configs.go#L81>)

```go
func (c *Config) WithConnectTimeout(d time.Duration) *Config
```



<a name="Config.WithKeepAlive"></a>
### func \(\*Config\) [WithKeepAlive](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/configs.go#L91>)

```go
func (c *Config) WithKeepAlive(enabled bool) *Config
```



<a name="Config.WithTimeout"></a>
### func \(\*Config\) [WithTimeout](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/configs.go#L76>)

```go
func (c *Config) WithTimeout(d time.Duration) *Config
```



<a name="Embedding"></a>
## type [Embedding](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/utils.go#L18-L22>)

Embedding represents a dense embedding vector.

```go
type Embedding struct {
    ID     string         // Unique identifier (same as Qdrant point ID)
    Vector []float32      // Vector representation of the embedding
    Meta   map[string]any // Optional metadata associated with the embedding
}
```

<a name="NewEmbedding"></a>
### func [NewEmbedding](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/utils.go#L54>)

```go
func NewEmbedding(input EmbeddingInput) Embedding
```

NewEmbedding converts a high\-level EmbeddingInput into the internal Embedding type. Having this builder allows for future validation or normalization logic. For now, it performs a shallow copy.

<a name="EmbeddingInput"></a>
## type [EmbeddingInput](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/utils.go#L11-L15>)

EmbeddingInput is the type the application provides to insert embeddings. Keeps the app decoupled from internal Qdrant SDK structs.

```go
type EmbeddingInput struct {
    ID     string         // Unique identifier for the embedding (e.g., document ID)
    Vector []float32      // Dense vector representation of the embedding
    Meta   map[string]any // Optional metadata associated with the embedding
}
```

<a name="FieldType"></a>
## type [FieldType](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/filters.go#L21>)

FieldType indicates whether a field is internal or user\-defined

```go
type FieldType int
```

<a name="InternalField"></a>

```go
const (
    // InternalField - system-managed fields stored at top-level
    InternalField FieldType = iota
    // UserField - user-defined fields stored under "custom." prefix
    UserField
)
```

<a name="FilterCondition"></a>
## type [FilterCondition](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/filters.go#L16-L18>)

FilterCondition is the interface for all filter conditions

```go
type FilterCondition interface {
    ToQdrantCondition() []*qdrant.Condition
}
```

<a name="FilterSet"></a>
## type [FilterSet](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/filters.go#L260-L264>)

FilterSet supports Must \(AND\), Should \(OR\), and MustNot \(NOT\) clauses. Use with SearchRequest.Filters to filter search results.

Example:

```
filters := &FilterSet{
    Must: &ConditionSet{
        Conditions: []FilterCondition{
            TextCondition{Key: "city", Value: "London"},
        },
    },
}
```

```go
type FilterSet struct {
    Must    *ConditionSet `json:"must,omitempty"`    // AND - all conditions must match
    Should  *ConditionSet `json:"should,omitempty"`  // OR - at least one condition must match
    MustNot *ConditionSet `json:"mustNot,omitempty"` // NOT - none of the conditions should match
}
```

<a name="IntAnyCondition"></a>
## type [IntAnyCondition](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/filters.go#L125>)



```go
type IntAnyCondition = MatchAnyCondition[int64] // Integer IN operator
```

<a name="IntCondition"></a>
## type [IntCondition](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/filters.go#L123>)



```go
type IntCondition = MatchCondition[int64] // Exact integer match
```

<a name="IntExceptCondition"></a>
## type [IntExceptCondition](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/filters.go#L127>)



```go
type IntExceptCondition = MatchExceptCondition[int64] // Integer NOT IN
```

<a name="IsEmptyCondition"></a>
## type [IsEmptyCondition](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/filters.go#L367-L370>)

IsEmptyCondition checks if a field is empty \(does not exist, null, or \[\]\)

```go
type IsEmptyCondition struct {
    Key       string    `json:"field"`
    FieldType FieldType `json:"-"` // Internal or User field (default: InternalField)
}
```

<a name="IsEmptyCondition.ToQdrantCondition"></a>
### func \(IsEmptyCondition\) [ToQdrantCondition](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/filters.go#L372>)

```go
func (c IsEmptyCondition) ToQdrantCondition() []*qdrant.Condition
```



<a name="IsNullCondition"></a>
## type [IsNullCondition](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/filters.go#L356-L359>)

IsNullCondition checks if a field is null

```go
type IsNullCondition struct {
    Key       string    `json:"field"`
    FieldType FieldType `json:"-"` // Internal or User field (default: InternalField)
}
```

<a name="IsNullCondition.ToQdrantCondition"></a>
### func \(IsNullCondition\) [ToQdrantCondition](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/filters.go#L361>)

```go
func (c IsNullCondition) ToQdrantCondition() []*qdrant.Condition
```



<a name="MatchAnyCondition"></a>
## type [MatchAnyCondition](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/filters.go#L76-L80>)

MatchAnyCondition matches if value is one of the given values \(IN operator\). Applicable to keyword \(string\) and integer payloads. Returns nil if Values is empty. The FieldType defaults to InternalField if not specified.

```go
type MatchAnyCondition[T string | int64] struct {
    Key       string    `json:"field"`
    Values    []T       `json:"anyOf"`
    FieldType FieldType `json:"-"` // Internal or User field (default: InternalField)
}
```

<a name="MatchAnyCondition[T].ToQdrantCondition"></a>
### func \(MatchAnyCondition\[T\]\) [ToQdrantCondition](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/filters.go#L82>)

```go
func (c MatchAnyCondition[T]) ToQdrantCondition() []*qdrant.Condition
```



<a name="MatchCondition"></a>
## type [MatchCondition](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/filters.go#L50-L54>)

MatchCondition represents an exact match condition for a field value. Supports string, bool, and int64 types. The FieldType defaults to InternalField if not specified, meaning the field is stored at the top level of the payload. Use UserField to indicate the field is stored under the "custom." prefix.

```go
type MatchCondition[T comparable] struct {
    Key       string    `json:"field"`
    Value     T         `json:"equalTo"`
    FieldType FieldType `json:"-"` // Internal or User field (default: InternalField)
}
```

<a name="MatchCondition[T].ToQdrantCondition"></a>
### func \(MatchCondition\[T\]\) [ToQdrantCondition](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/filters.go#L58>)

```go
func (c MatchCondition[T]) ToQdrantCondition() []*qdrant.Condition
```

ToQdrantCondition converts the MatchCondition to Qdrant conditions. Supports string, bool, and int64 types. Returns nil for unsupported types.

<a name="MatchExceptCondition"></a>
## type [MatchExceptCondition](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/filters.go#L100-L104>)

MatchExceptCondition matches if value is NOT one of the given values \(NOT IN operator\). Applicable to keyword \(string\) and integer payloads. Returns nil if Values is empty. The FieldType defaults to InternalField if not specified.

```go
type MatchExceptCondition[T string | int64] struct {
    Key       string    `json:"field"`
    Values    []T       `json:"noneOf"`
    FieldType FieldType `json:"-"` // Internal or User field (default: InternalField)
}
```

<a name="MatchExceptCondition[T].ToQdrantCondition"></a>
### func \(MatchExceptCondition\[T\]\) [ToQdrantCondition](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/filters.go#L106>)

```go
func (c MatchExceptCondition[T]) ToQdrantCondition() []*qdrant.Condition
```



<a name="NumericRange"></a>
## type [NumericRange](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/filters.go#L39-L44>)

NumericRange represents a numeric range filter condition

```go
type NumericRange struct {
    Gt  *float64 `json:"greaterThan,omitempty"`          // Greater than
    Gte *float64 `json:"greaterThanOrEqualTo,omitempty"` // Greater than or equal
    Lt  *float64 `json:"lessThan,omitempty"`             // Less than
    Lte *float64 `json:"lessThanOrEqualTo,omitempty"`    // Less than or equal
}
```

<a name="NumericRangeCondition"></a>
## type [NumericRangeCondition](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/filters.go#L180-L184>)

NumericRangeCondition represents a numeric range filter

```go
type NumericRangeCondition struct {
    Key       string       `json:"field"`
    Value     NumericRange `json:"-"`
    FieldType FieldType    `json:"-"`
}
```

<a name="NumericRangeCondition.MarshalJSON"></a>
### func \(NumericRangeCondition\) [MarshalJSON](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/filters.go#L190>)

```go
func (c NumericRangeCondition) MarshalJSON() ([]byte, error)
```



<a name="NumericRangeCondition.ToQdrantCondition"></a>
### func \(NumericRangeCondition\) [ToQdrantCondition](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/filters.go#L186>)

```go
func (c NumericRangeCondition) ToQdrantCondition() []*qdrant.Condition
```



<a name="NumericRangeCondition.UnmarshalJSON"></a>
### func \(\*NumericRangeCondition\) [UnmarshalJSON](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/filters.go#L207>)

```go
func (c *NumericRangeCondition) UnmarshalJSON(data []byte) error
```



<a name="QdrantClient"></a>
## type [QdrantClient](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/client.go#L34-L38>)



```go
type QdrantClient struct {
    // contains filtered or unexported fields
}
```

<a name="NewQdrantClient"></a>
### func [NewQdrantClient](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/client.go#L58>)

```go
func NewQdrantClient(p QdrantParams) (*QdrantClient, error)
```

NewQdrantClient ────────────────────────────────────────────────────────────── NewQdrantClient ──────────────────────────────────────────────────────────────

NewQdrantClient constructs a new instance of QdrantClient and validates connectivity via a health check.

The Qdrant Go SDK creates lightweight gRPC connections, so this method performs an immediate health check to fail fast if the service is unreachable.

Example:

```
client, _ := qdrant.NewQdrantClient(qdrant.QdrantParams{Config: cfg})
```

<a name="QdrantClient.BatchInsert"></a>
### func \(\*QdrantClient\) [BatchInsert](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/operations.go#L80>)

```go
func (c *QdrantClient) BatchInsert(ctx context.Context, collectionName string, inputs []EmbeddingInput) error
```

BatchInsert ────────────────────────────────────────────────────────────── BatchInsert ──────────────────────────────────────────────────────────────

BatchInsert efficiently inserts multiple embeddings in batches to reduce network overhead.

This method is safe to call for large datasets — it will automatically split inserts into smaller chunks \(\`defaultBatchSize\`\) and perform multiple upserts sequentially.

Logs batch indices and collection name for debugging.

<a name="QdrantClient.Close"></a>
### func \(\*QdrantClient\) [Close](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/client.go#L125>)

```go
func (c *QdrantClient) Close() error
```

Close ────────────────────────────────────────────────────────────── Close ──────────────────────────────────────────────────────────────

Close gracefully shuts down the Qdrant client.

Since the official Qdrant Go SDK doesn’t maintain persistent connections, this is currently a no\-op. It exists for lifecycle symmetry and future safety.

<a name="QdrantClient.Delete"></a>
### func \(\*QdrantClient\) [Delete](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/operations.go#L449>)

```go
func (c *QdrantClient) Delete(ctx context.Context, collectionName string, ids []string) error
```

Delete ────────────────────────────────────────────────────────────── Delete ──────────────────────────────────────────────────────────────

Delete removes embeddings from a collection by their IDs.

It constructs a \`DeletePoints\` request containing a list of \`PointId\`s, waits synchronously for completion, and logs the operation status.

<a name="QdrantClient.EnsureCollection"></a>
### func \(\*QdrantClient\) [EnsureCollection](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/operations.go#L23>)

```go
func (c *QdrantClient) EnsureCollection(ctx context.Context, name string) error
```

EnsureCollection ────────────────────────────────────────────────────────────── EnsureCollection ──────────────────────────────────────────────────────────────

EnsureCollection verifies if a given collection exists, and creates it if missing.

It’s safe to call this multiple times — if the collection already exists, the function exits early. This pattern simplifies startup logic for embedding services that may bootstrap their own Qdrant collections.

<a name="QdrantClient.GetCollection"></a>
### func \(\*QdrantClient\) [GetCollection](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/operations.go#L176>)

```go
func (c *QdrantClient) GetCollection(ctx context.Context, name string) (*Collection, error)
```



<a name="QdrantClient.Insert"></a>
### func \(\*QdrantClient\) [Insert](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/operations.go#L64>)

```go
func (c *QdrantClient) Insert(ctx context.Context, collectionName string, input EmbeddingInput) error
```

Insert ────────────────────────────────────────────────────────────── Insert ──────────────────────────────────────────────────────────────

Insert adds a single embedding to Qdrant.

Internally, it reuses the BatchInsert logic to ensure consistent handling of payload serialization and error management.

<a name="QdrantClient.ListCollections"></a>
### func \(\*QdrantClient\) [ListCollections](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/operations.go#L219>)

```go
func (c *QdrantClient) ListCollections(ctx context.Context) ([]string, error)
```

ListCollections ────────────────────────────────────────────────────────────── ListCollections ──────────────────────────────────────────────────────────────

ListCollections retrieves all existing collections from Qdrant and returns their names as a string slice. This can be extended to preload metadata using GetCollection for each name if needed.

Example:

```
names, err := client.ListCollections(ctx)
if err != nil {
    log.Fatalf("failed to list collections: %v", err)
}
log.Printf("Found collections: %v", names)
```

<a name="QdrantClient.Search"></a>
### func \(\*QdrantClient\) [Search](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/operations.go#L368>)

```go
func (c *QdrantClient) Search(ctx context.Context, requests ...SearchRequest) ([][]SearchResultInterface, error)
```

Search ────────────────────────────────────────────────────────────── Search ──────────────────────────────────────────────────────────────

Search performs multiple searches and returns results for each request. Each request can optionally include filters.

Parameters:

- requests — variadic SearchRequest structs, each containing:
- CollectionName: the collection to search in
- Vector: the query embedding
- TopK: maximum number of results per request
- Filters: optional key\-value filters \(AND logic\)

Returns:

```
A slice of result slices — one []SearchResultInterface per request.
```

Example:

```
results, err := client.Search(ctx,
    SearchRequest{CollectionName: "docs", Vector: vec1, TopK: 10, Filters: map[string]string{"partition_id": "store-A"}},
    SearchRequest{CollectionName: "docs", Vector: vec2, TopK: 5},
)
// results[0] = results for first request
// results[1] = results for second request
```

<a name="QdrantParams"></a>
## type [QdrantParams](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/fx_module.go#L39-L42>)

QdrantParams defines dependencies needed to construct the Qdrant client.

```go
type QdrantParams struct {
    fx.In
    Config *Config
}
```

<a name="SearchRequest"></a>
## type [SearchRequest](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/utils.go#L99-L104>)

SearchRequest represents a single search request for batch operations

```go
type SearchRequest struct {
    CollectionName string
    Vector         []float32
    TopK           int
    Filters        *FilterSet // Optional: key-value filters
}
```

<a name="SearchResult"></a>
## type [SearchResult](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/utils.go#L25-L31>)

SearchResult holds results from a similarity search.

```go
type SearchResult struct {
    ID         string
    Score      float32
    Meta       map[string]*qdrant.Value
    Vector     []float32
    Collection string
}
```

<a name="SearchResult.GetCollectionName"></a>
### func \(SearchResult\) [GetCollectionName](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/utils.go#L49>)

```go
func (r SearchResult) GetCollectionName() string
```

GetCollectionName returns the name of the collection from which the result originated.

<a name="SearchResult.GetID"></a>
### func \(SearchResult\) [GetID](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/utils.go#L34>)

```go
func (r SearchResult) GetID() string
```

GetID returns the result's unique identifier.

<a name="SearchResult.GetMeta"></a>
### func \(SearchResult\) [GetMeta](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/utils.go#L40>)

```go
func (r SearchResult) GetMeta() map[string]*qdrant.Value
```

GetMeta returns the metadata stored with the vector.

<a name="SearchResult.GetScore"></a>
### func \(SearchResult\) [GetScore](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/utils.go#L37>)

```go
func (r SearchResult) GetScore() float32
```

GetScore returns the similarity score associated with the result.

<a name="SearchResult.GetVector"></a>
### func \(SearchResult\) [GetVector](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/utils.go#L43>)

```go
func (r SearchResult) GetVector() []float32
```

GetVector returns the dense embedding vector if available.

<a name="SearchResult.HasVector"></a>
### func \(SearchResult\) [HasVector](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/utils.go#L46>)

```go
func (r SearchResult) HasVector() bool
```

HasVector reports whether the result contains a non\-empty vector payload.

<a name="SearchResultInterface"></a>
## type [SearchResultInterface](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/utils.go#L60-L67>)

SearchResultInterface is the public interface for search results. It provides a consistent way to access search results regardless of the underlying implementation.

```go
type SearchResultInterface interface {
    GetID() string                     // Unique result identifier
    GetScore() float32                 // Similarity score
    GetMeta() map[string]*qdrant.Value // Metadata associated with the result
    GetVector() []float32              // Optional embedding vector
    HasVector() bool                   // Whether a vector payload is present
    GetCollectionName() string         // Name of the Qdrant collection
}
```

<a name="TextAnyCondition"></a>
## type [TextAnyCondition](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/filters.go#L124>)



```go
type TextAnyCondition = MatchAnyCondition[string] // String IN operator
```

<a name="TextCondition"></a>
## type [TextCondition](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/filters.go#L121>)



```go
type TextCondition = MatchCondition[string] // Exact string match
```

<a name="TextExceptCondition"></a>
## type [TextExceptCondition](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/filters.go#L126>)



```go
type TextExceptCondition = MatchExceptCondition[string] // String NOT IN
```

<a name="TimeRange"></a>
## type [TimeRange](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/filters.go#L31-L36>)

TimeRange represents a time\-based filter condition

```go
type TimeRange struct {
    Gt  *time.Time `json:"after,omitempty"`      // Greater than this time
    Gte *time.Time `json:"atOrAfter,omitempty"`  // Greater than or equal to this time
    Lt  *time.Time `json:"before,omitempty"`     // Less than this time
    Lte *time.Time `json:"atOrBefore,omitempty"` // Less than or equal to this time
}
```

<a name="TimeRangeCondition"></a>
## type [TimeRangeCondition](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/filters.go#L130-L134>)

TimeRangeCondition represents a time range filter condition

```go
type TimeRangeCondition struct {
    Key       string    `json:"field"`
    Value     TimeRange `json:"-"`
    FieldType FieldType `json:"-"`
}
```

<a name="TimeRangeCondition.MarshalJSON"></a>
### func \(TimeRangeCondition\) [MarshalJSON](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/filters.go#L140>)

```go
func (c TimeRangeCondition) MarshalJSON() ([]byte, error)
```



<a name="TimeRangeCondition.ToQdrantCondition"></a>
### func \(TimeRangeCondition\) [ToQdrantCondition](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/filters.go#L136>)

```go
func (c TimeRangeCondition) ToQdrantCondition() []*qdrant.Condition
```



<a name="TimeRangeCondition.UnmarshalJSON"></a>
### func \(\*TimeRangeCondition\) [UnmarshalJSON](<https://github.com/Aleph-Alpha/std/blob/main/v1/qdrant/filters.go#L157>)

```go
func (c *TimeRangeCondition) UnmarshalJSON(data []byte) error
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
