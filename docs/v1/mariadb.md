<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# mariadb

```go
import "github.com/Aleph-Alpha/std/v1/mariadb"
```

Package mariadb provides functionality for interacting with MariaDB and MySQL databases.

The mariadb package offers a robust interface for working with MariaDB/MySQL databases, built on top of GORM ORM. It includes connection management, query execution, transaction handling, and migration tools.

Core Features:

- Connection pooling and management with automatic reconnection
- Parameterized query execution via GORM
- Transaction support with automatic rollback on errors
- Schema migration tools
- Row scanning utilities
- Basic CRUD operations with thread safety
- Query builder for complex queries

Basic Usage:

```
import (
	"github.com/Aleph-Alpha/std/v1/mariadb"
)

// Create a new database connection
db, err := mariadb.NewMariaDB(mariadb.Config{
	Connection: mariadb.Connection{
		Host:      "localhost",
		Port:      "3306",
		User:      "root",
		Password:  "password",
		DbName:    "mydb",
		Charset:   "utf8mb4",
		ParseTime: true,
	},
})
if err != nil {
	log.Fatal("Failed to connect to database", err)
}
defer db.GracefulShutdown()

// Execute a query
var users []User
err = db.Find(context.Background(), &users, "age > ?", 18)
if err != nil {
	log.Error("Query failed", err)
}
```

Transaction Example:

```
err = db.Transaction(ctx, func(txDB *mariadb.MariaDB) error {
	// Execute multiple queries in a transaction
	if err := txDB.Create(ctx, &user); err != nil {
		return err  // Transaction will be rolled back
	}

	if err := txDB.Create(ctx, &userProfile); err != nil {
		return err  // Transaction will be rolled back
	}

	return nil  // Transaction will be committed
})
```

Query Builder Example:

```
// Build complex queries
var users []User
err := db.Query(ctx).
    Where("age > ?", 18).
    Where("status = ?", "active").
    Order("created_at DESC").
    Limit(10).
    Find(&users)
```

Basic Operations:

```
// Create a record
err := db.Create(ctx, &user)

// Get a single record
var user User
err = db.First(ctx, &user, "email = ?", "john@example.com")

// Update records
rowsAffected, err := db.Update(ctx, &user, map[string]interface{}{
    "name": "John Doe Updated",
})

// Delete records
rowsAffected, err := db.Delete(ctx, &User{}, "id = ?", 123)
```

FX Module Integration:

This package provides an fx module for easy integration:

```
app := fx.New(
	mariadb.FXModule,
	fx.Provide(
		func() mariadb.Config {
			return mariadb.Config{
				Connection: mariadb.Connection{
					Host:     "localhost",
					Port:     "3306",
					User:     "root",
					Password: "password",
					DbName:   "mydb",
				},
			}
		},
	),
	// ... other modules
)
app.Run()
```

Error Handling:

All methods in this package return GORM errors directly. This design provides:

- Consistency: All methods behave the same way
- Flexibility: Consumers can use errors.Is\(\) with GORM error types
- Performance: No translation overhead unless needed
- Transparency: Preserves the full error chain from GORM

Basic error handling with GORM errors:

```
var user User
err := db.First(ctx, &user, "email = ?", "user@example.com")
if errors.Is(err, gorm.ErrRecordNotFound) {
    // Handle not found
}

err = db.Query(ctx).Where("email = ?", "user@example.com").First(&user)
if errors.Is(err, gorm.ErrRecordNotFound) {
    // Handle not found
}
```

For standardized error types, use TranslateError\(\):

```
err := db.First(ctx, &user, conditions)
if err != nil {
    err = db.TranslateError(err)
    if errors.Is(err, mariadb.ErrRecordNotFound) {
        // Handle not found with standardized error
    }
}
```

Recommended pattern \- create a helper function for common error checks:

```
func isRecordNotFound(err error) bool {
    return errors.Is(err, gorm.ErrRecordNotFound)
}

// Use consistently throughout your codebase
if isRecordNotFound(err) {
    // Handle not found
}
```

Differences from PostgreSQL Package:

This package provides nearly identical functionality to the postgres package, with the following notable differences:

- Connection configuration uses MySQL DSN format instead of PostgreSQL format
- ForNoKeyUpdate\(\) is not available \(PostgreSQL\-only feature\)
- ForKeyShare\(\) is not available \(PostgreSQL\-only feature\)
- Returning\(\) clause is not available \(use LAST\_INSERT\_ID\(\) for inserts\)
- SKIP LOCKED and NOWAIT require MySQL 8.0\+ or MariaDB 10.3\+/10.6\+

Performance Considerations:

- Connection pooling is automatically handled to optimize performance
- Prepared statements are used internally to reduce parsing overhead
- Consider using batch operations for multiple insertions
- Query timeouts are recommended for all database operations

Thread Safety:

All methods on the MariaDB interface are safe for concurrent use by multiple goroutines. Internal mutexes ensure thread\-safe access to the database connection.

## Index

- [Variables](<#variables>)
- [func RegisterMariaDBLifecycle\(params MariaDBLifeCycleParams\)](<#RegisterMariaDBLifecycle>)
- [type Config](<#Config>)
- [type Connection](<#Connection>)
- [type ConnectionDetails](<#ConnectionDetails>)
- [type ErrorCategory](<#ErrorCategory>)
- [type MariaDB](<#MariaDB>)
  - [func NewMariaDB\(cfg Config\) \(\*MariaDB, error\)](<#NewMariaDB>)
  - [func NewMariaDBClientWithDI\(params MariaDBParams\) \(\*MariaDB, error\)](<#NewMariaDBClientWithDI>)
  - [func \(p \*MariaDB\) AutoMigrate\(models ...interface\{\}\) error](<#MariaDB.AutoMigrate>)
  - [func \(m \*MariaDB\) Count\(ctx context.Context, model interface\{\}, count \*int64, conditions ...interface\{\}\) error](<#MariaDB.Count>)
  - [func \(m \*MariaDB\) Create\(ctx context.Context, value interface\{\}\) error](<#MariaDB.Create>)
  - [func \(p \*MariaDB\) CreateMigration\(migrationsDir, name string, migrationType MigrationType\) \(string, error\)](<#MariaDB.CreateMigration>)
  - [func \(m \*MariaDB\) DB\(\) \*gorm.DB](<#MariaDB.DB>)
  - [func \(m \*MariaDB\) Delete\(ctx context.Context, value interface\{\}, conditions ...interface\{\}\) \(int64, error\)](<#MariaDB.Delete>)
  - [func \(m \*MariaDB\) Exec\(ctx context.Context, sql string, values ...interface\{\}\) \(int64, error\)](<#MariaDB.Exec>)
  - [func \(m \*MariaDB\) Find\(ctx context.Context, dest interface\{\}, conditions ...interface\{\}\) error](<#MariaDB.Find>)
  - [func \(m \*MariaDB\) First\(ctx context.Context, dest interface\{\}, conditions ...interface\{\}\) error](<#MariaDB.First>)
  - [func \(m \*MariaDB\) GetErrorCategory\(err error\) ErrorCategory](<#MariaDB.GetErrorCategory>)
  - [func \(p \*MariaDB\) GetMigrationStatus\(ctx context.Context, migrationsDir string\) \(\[\]map\[string\]interface\{\}, error\)](<#MariaDB.GetMigrationStatus>)
  - [func \(m \*MariaDB\) GracefulShutdown\(\) error](<#MariaDB.GracefulShutdown>)
  - [func \(m \*MariaDB\) IsCritical\(err error\) bool](<#MariaDB.IsCritical>)
  - [func \(m \*MariaDB\) IsRetryable\(err error\) bool](<#MariaDB.IsRetryable>)
  - [func \(m \*MariaDB\) IsTemporary\(err error\) bool](<#MariaDB.IsTemporary>)
  - [func \(p \*MariaDB\) MigrateDown\(ctx context.Context, migrationsDir string\) error](<#MariaDB.MigrateDown>)
  - [func \(p \*MariaDB\) MigrateUp\(ctx context.Context, migrationsDir string\) error](<#MariaDB.MigrateUp>)
  - [func \(m \*MariaDB\) MonitorConnection\(ctx context.Context\)](<#MariaDB.MonitorConnection>)
  - [func \(m \*MariaDB\) Query\(ctx context.Context\) \*QueryBuilder](<#MariaDB.Query>)
  - [func \(m \*MariaDB\) RetryConnection\(ctx context.Context\)](<#MariaDB.RetryConnection>)
  - [func \(m \*MariaDB\) Save\(ctx context.Context, value interface\{\}\) error](<#MariaDB.Save>)
  - [func \(m \*MariaDB\) Transaction\(ctx context.Context, fn func\(db \*MariaDB\) error\) error](<#MariaDB.Transaction>)
  - [func \(m \*MariaDB\) TranslateError\(err error\) error](<#MariaDB.TranslateError>)
  - [func \(m \*MariaDB\) Update\(ctx context.Context, model interface\{\}, attrs interface\{\}\) \(int64, error\)](<#MariaDB.Update>)
  - [func \(m \*MariaDB\) UpdateColumn\(ctx context.Context, model interface\{\}, columnName string, value interface\{\}\) \(int64, error\)](<#MariaDB.UpdateColumn>)
  - [func \(m \*MariaDB\) UpdateColumns\(ctx context.Context, model interface\{\}, columnValues map\[string\]interface\{\}\) \(int64, error\)](<#MariaDB.UpdateColumns>)
  - [func \(m \*MariaDB\) UpdateWhere\(ctx context.Context, model interface\{\}, attrs interface\{\}, condition string, args ...interface\{\}\) \(int64, error\)](<#MariaDB.UpdateWhere>)
- [type MariaDBLifeCycleParams](<#MariaDBLifeCycleParams>)
- [type MariaDBParams](<#MariaDBParams>)
- [type Migration](<#Migration>)
- [type MigrationDirection](<#MigrationDirection>)
- [type MigrationHistoryRecord](<#MigrationHistoryRecord>)
- [type MigrationType](<#MigrationType>)
- [type QueryBuilder](<#QueryBuilder>)
  - [func \(qb \*QueryBuilder\) Clauses\(conds ...clause.Expression\) \*QueryBuilder](<#QueryBuilder.Clauses>)
  - [func \(qb \*QueryBuilder\) Count\(count \*int64\) error](<#QueryBuilder.Count>)
  - [func \(qb \*QueryBuilder\) Create\(value interface\{\}\) \(int64, error\)](<#QueryBuilder.Create>)
  - [func \(qb \*QueryBuilder\) CreateInBatches\(value interface\{\}, batchSize int\) \(int64, error\)](<#QueryBuilder.CreateInBatches>)
  - [func \(qb \*QueryBuilder\) Delete\(value interface\{\}\) \(int64, error\)](<#QueryBuilder.Delete>)
  - [func \(qb \*QueryBuilder\) Distinct\(args ...interface\{\}\) \*QueryBuilder](<#QueryBuilder.Distinct>)
  - [func \(qb \*QueryBuilder\) Done\(\)](<#QueryBuilder.Done>)
  - [func \(qb \*QueryBuilder\) Find\(dest interface\{\}\) error](<#QueryBuilder.Find>)
  - [func \(qb \*QueryBuilder\) First\(dest interface\{\}\) error](<#QueryBuilder.First>)
  - [func \(qb \*QueryBuilder\) FirstOrCreate\(dest interface\{\}, conds ...interface\{\}\) error](<#QueryBuilder.FirstOrCreate>)
  - [func \(qb \*QueryBuilder\) FirstOrInit\(dest interface\{\}, conds ...interface\{\}\) error](<#QueryBuilder.FirstOrInit>)
  - [func \(qb \*QueryBuilder\) ForShare\(\) \*QueryBuilder](<#QueryBuilder.ForShare>)
  - [func \(qb \*QueryBuilder\) ForShareSkipLocked\(\) \*QueryBuilder](<#QueryBuilder.ForShareSkipLocked>)
  - [func \(qb \*QueryBuilder\) ForUpdate\(\) \*QueryBuilder](<#QueryBuilder.ForUpdate>)
  - [func \(qb \*QueryBuilder\) ForUpdateNoWait\(\) \*QueryBuilder](<#QueryBuilder.ForUpdateNoWait>)
  - [func \(qb \*QueryBuilder\) ForUpdateSkipLocked\(\) \*QueryBuilder](<#QueryBuilder.ForUpdateSkipLocked>)
  - [func \(qb \*QueryBuilder\) Group\(query string\) \*QueryBuilder](<#QueryBuilder.Group>)
  - [func \(qb \*QueryBuilder\) Having\(query interface\{\}, args ...interface\{\}\) \*QueryBuilder](<#QueryBuilder.Having>)
  - [func \(qb \*QueryBuilder\) Joins\(query string, args ...interface\{\}\) \*QueryBuilder](<#QueryBuilder.Joins>)
  - [func \(qb \*QueryBuilder\) Last\(dest interface\{\}\) error](<#QueryBuilder.Last>)
  - [func \(qb \*QueryBuilder\) LeftJoin\(query string, args ...interface\{\}\) \*QueryBuilder](<#QueryBuilder.LeftJoin>)
  - [func \(qb \*QueryBuilder\) Limit\(limit int\) \*QueryBuilder](<#QueryBuilder.Limit>)
  - [func \(qb \*QueryBuilder\) MapRows\(destSlice interface\{\}, mapFn func\(\*gorm.DB\) error\) error](<#QueryBuilder.MapRows>)
  - [func \(qb \*QueryBuilder\) Model\(value interface\{\}\) \*QueryBuilder](<#QueryBuilder.Model>)
  - [func \(qb \*QueryBuilder\) Not\(query interface\{\}, args ...interface\{\}\) \*QueryBuilder](<#QueryBuilder.Not>)
  - [func \(qb \*QueryBuilder\) Offset\(offset int\) \*QueryBuilder](<#QueryBuilder.Offset>)
  - [func \(qb \*QueryBuilder\) OnConflict\(onConflict clause.OnConflict\) \*QueryBuilder](<#QueryBuilder.OnConflict>)
  - [func \(qb \*QueryBuilder\) Or\(query interface\{\}, args ...interface\{\}\) \*QueryBuilder](<#QueryBuilder.Or>)
  - [func \(qb \*QueryBuilder\) Order\(value interface\{\}\) \*QueryBuilder](<#QueryBuilder.Order>)
  - [func \(qb \*QueryBuilder\) Pluck\(column string, dest interface\{\}\) \(int64, error\)](<#QueryBuilder.Pluck>)
  - [func \(qb \*QueryBuilder\) Preload\(query string, args ...interface\{\}\) \*QueryBuilder](<#QueryBuilder.Preload>)
  - [func \(qb \*QueryBuilder\) QueryRow\(\) RowScanner](<#QueryBuilder.QueryRow>)
  - [func \(qb \*QueryBuilder\) QueryRows\(\) \(RowsScanner, error\)](<#QueryBuilder.QueryRows>)
  - [func \(qb \*QueryBuilder\) Raw\(sql string, values ...interface\{\}\) \*QueryBuilder](<#QueryBuilder.Raw>)
  - [func \(qb \*QueryBuilder\) RightJoin\(query string, args ...interface\{\}\) \*QueryBuilder](<#QueryBuilder.RightJoin>)
  - [func \(qb \*QueryBuilder\) Scan\(dest interface\{\}\) error](<#QueryBuilder.Scan>)
  - [func \(qb \*QueryBuilder\) ScanRow\(dest interface\{\}\) error](<#QueryBuilder.ScanRow>)
  - [func \(qb \*QueryBuilder\) Scopes\(funcs ...func\(\*gorm.DB\) \*gorm.DB\) \*QueryBuilder](<#QueryBuilder.Scopes>)
  - [func \(qb \*QueryBuilder\) Select\(query interface\{\}, args ...interface\{\}\) \*QueryBuilder](<#QueryBuilder.Select>)
  - [func \(qb \*QueryBuilder\) Table\(name string\) \*QueryBuilder](<#QueryBuilder.Table>)
  - [func \(qb \*QueryBuilder\) ToSubquery\(\) \*gorm.DB](<#QueryBuilder.ToSubquery>)
  - [func \(qb \*QueryBuilder\) Unscoped\(\) \*QueryBuilder](<#QueryBuilder.Unscoped>)
  - [func \(qb \*QueryBuilder\) Updates\(values interface\{\}\) \(int64, error\)](<#QueryBuilder.Updates>)
  - [func \(qb \*QueryBuilder\) Where\(query interface\{\}, args ...interface\{\}\) \*QueryBuilder](<#QueryBuilder.Where>)
- [type RowScanner](<#RowScanner>)
- [type RowsScanner](<#RowsScanner>)


## Variables

<a name="ErrRecordNotFound"></a>Common database error types that can be used by consumers of this package. These provide a standardized set of errors that abstract away the underlying database\-specific error details.

```go
var (
    // ErrRecordNotFound is returned when a query doesn't find any matching records
    ErrRecordNotFound = errors.New("record not found")

    // ErrDuplicateKey is returned when an insert or update violates a unique constraint
    ErrDuplicateKey = errors.New("duplicate key violation")

    // ErrForeignKey is returned when an operation violates a foreign key constraint
    ErrForeignKey = errors.New("foreign key violation")

    // ErrInvalidData is returned when the data being saved doesn't meet validation rules
    ErrInvalidData = errors.New("invalid data")

    // ErrConnectionFailed is returned when database connection cannot be established
    ErrConnectionFailed = errors.New("database connection failed")

    // ErrTransactionFailed is returned when a transaction fails to commit or rollback
    ErrTransactionFailed = errors.New("transaction failed")

    // ErrQueryTimeout is returned when a query exceeds the allowed timeout
    ErrQueryTimeout = errors.New("query timeout exceeded")

    // ErrInvalidQuery is returned when the SQL query is malformed or invalid
    ErrInvalidQuery = errors.New("invalid query")

    // ErrPermissionDenied is returned when the user lacks necessary permissions
    ErrPermissionDenied = errors.New("permission denied")

    // ErrTableNotFound is returned when trying to access a non-existent table
    ErrTableNotFound = errors.New("table not found")

    // ErrColumnNotFound is returned when trying to access a non-existent column
    ErrColumnNotFound = errors.New("column not found")

    // ErrConstraintViolation is returned for general constraint violations
    ErrConstraintViolation = errors.New("constraint violation")

    // ErrCheckConstraintViolation is returned when a check constraint is violated
    ErrCheckConstraintViolation = errors.New("check constraint violation")

    // ErrNotNullViolation is returned when trying to insert null into a not-null column
    ErrNotNullViolation = errors.New("not null constraint violation")

    // ErrDataTooLong is returned when data exceeds column length limits
    ErrDataTooLong = errors.New("data too long for column")

    // ErrDeadlock is returned when a deadlock is detected during transaction
    ErrDeadlock = errors.New("deadlock detected")

    // ErrLockTimeout is returned when unable to acquire lock within timeout
    ErrLockTimeout = errors.New("lock acquisition timeout")

    // ErrInvalidDataType is returned when data type conversion fails
    ErrInvalidDataType = errors.New("invalid data type")

    // ErrDivisionByZero is returned for division by zero operations
    ErrDivisionByZero = errors.New("division by zero")

    // ErrNumericOverflow is returned when numeric operation causes overflow
    ErrNumericOverflow = errors.New("numeric value overflow")

    // ErrDiskFull is returned when database storage is full
    ErrDiskFull = errors.New("disk full")

    // ErrTooManyConnections is returned when connection pool is exhausted
    ErrTooManyConnections = errors.New("too many connections")

    // ErrInvalidJSON is returned when JSON data is malformed
    ErrInvalidJSON = errors.New("invalid JSON data")

    // ErrIndexCorruption is returned when database index is corrupted
    ErrIndexCorruption = errors.New("index corruption detected")

    // ErrConfigurationError is returned for database configuration issues
    ErrConfigurationError = errors.New("database configuration error")

    // ErrUnsupportedOperation is returned for operations not supported by the database
    ErrUnsupportedOperation = errors.New("unsupported operation")

    // ErrMigrationFailed is returned when database migration fails
    ErrMigrationFailed = errors.New("migration failed")

    // ErrBackupFailed is returned when database backup operation fails
    ErrBackupFailed = errors.New("backup operation failed")

    // ErrRestoreFailed is returned when database restore operation fails
    ErrRestoreFailed = errors.New("restore operation failed")

    // ErrSchemaValidation is returned when schema validation fails
    ErrSchemaValidation = errors.New("schema validation failed")

    // ErrSerializationFailure is returned when transaction serialization fails
    ErrSerializationFailure = errors.New("serialization failure")

    // ErrInsufficientPrivileges is returned when user lacks required privileges
    ErrInsufficientPrivileges = errors.New("insufficient privileges")

    // ErrInvalidPassword is returned for authentication failures
    ErrInvalidPassword = errors.New("invalid password")

    // ErrAccountLocked is returned when user account is locked
    ErrAccountLocked = errors.New("account locked")

    // ErrDatabaseNotFound is returned when specified database doesn't exist
    ErrDatabaseNotFound = errors.New("database not found")

    // ErrSchemaNotFound is returned when specified schema doesn't exist
    ErrSchemaNotFound = errors.New("schema not found")

    // ErrFunctionNotFound is returned when specified function doesn't exist
    ErrFunctionNotFound = errors.New("function not found")

    // ErrTriggerNotFound is returned when specified trigger doesn't exist
    ErrTriggerNotFound = errors.New("trigger not found")

    // ErrIndexNotFound is returned when specified index doesn't exist
    ErrIndexNotFound = errors.New("index not found")

    // ErrViewNotFound is returned when specified view doesn't exist
    ErrViewNotFound = errors.New("view not found")

    // ErrSequenceNotFound is returned when specified sequence doesn't exist
    ErrSequenceNotFound = errors.New("sequence not found")

    // ErrInvalidCursor is returned when cursor operation fails
    ErrInvalidCursor = errors.New("invalid cursor")

    // ErrCursorNotFound is returned when specified cursor doesn't exist
    ErrCursorNotFound = errors.New("cursor not found")

    // ErrStatementTimeout is returned when statement execution exceeds timeout
    ErrStatementTimeout = errors.New("statement timeout")

    // ErrIdleInTransaction is returned when transaction is idle too long
    ErrIdleInTransaction = errors.New("idle in transaction timeout")

    // ErrConnectionLost is returned when database connection is lost
    ErrConnectionLost = errors.New("connection lost")

    // ErrProtocolViolation is returned for database protocol violations
    ErrProtocolViolation = errors.New("protocol violation")

    // ErrInternalError is returned for internal database errors
    ErrInternalError = errors.New("internal database error")

    // ErrSystemError is returned for system-level database errors
    ErrSystemError = errors.New("system error")
)
```

<a name="FXModule"></a>FXModule is an fx module that provides the MariaDB database component. It registers the MariaDB constructor for dependency injection and sets up lifecycle hooks to properly initialize and shut down the database connection.

```go
var FXModule = fx.Module("mariadb",
    fx.Provide(
        NewMariaDBClientWithDI,
    ),
    fx.Invoke(RegisterMariaDBLifecycle),
)
```

<a name="RegisterMariaDBLifecycle"></a>
## func [RegisterMariaDBLifecycle](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/fx_module.go#L84>)

```go
func RegisterMariaDBLifecycle(params MariaDBLifeCycleParams)
```

RegisterMariaDBLifecycle registers lifecycle hooks for the MariaDB database component. It sets up: 1. Connection monitoring on the application starts 2. Automatic reconnection mechanism on application start 3. Graceful shutdown of database connections on application stop

The function uses a WaitGroup to ensure that all goroutines complete before the application terminates.

<a name="Config"></a>
## type [Config](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/configs.go#L7-L13>)

Config represents the complete configuration for a MariaDB/MySQL database connection. It encapsulates both the basic connection parameters and detailed connection pool settings.

```go
type Config struct {
    // Connection contains the essential parameters needed to establish a database connection
    Connection Connection

    // ConnectionDetails contains configuration for the connection pool behavior
    ConnectionDetails ConnectionDetails
}
```

<a name="Connection"></a>
## type [Connection](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/configs.go#L17-L63>)

Connection holds the basic parameters required to connect to a MariaDB/MySQL database. These parameters are used to construct the database connection DSN.

```go
type Connection struct {
    // Host specifies the database server hostname or IP address
    Host string

    // Port specifies the TCP port on which the database server is listening
    Port string

    // User specifies the database username for authentication
    User string

    // Password specifies the database user password for authentication
    Password string

    // DbName specifies the name of the database to connect to
    DbName string

    // Charset specifies the character set to use for the connection
    // Common values: "utf8mb4" (recommended), "utf8", "latin1"
    // Default: "utf8mb4"
    Charset string

    // ParseTime enables parsing of DATE and DATETIME values to time.Time
    // Recommended: true
    ParseTime bool

    // Loc specifies the location for parsing timestamps
    // Common values: "Local", "UTC"
    // Default: "Local"
    Loc string

    // TLS specifies the TLS/SSL configuration name
    // Common values: "true", "false", "skip-verify", "preferred", or a custom TLS config name
    // Default: "false"
    TLS string

    // Timeout specifies the connection timeout
    // Example: "10s", "30s"
    Timeout string

    // ReadTimeout specifies the I/O read timeout
    // Example: "30s"
    ReadTimeout string

    // WriteTimeout specifies the I/O write timeout
    // Example: "30s"
    WriteTimeout string
}
```

<a name="ConnectionDetails"></a>
## type [ConnectionDetails](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/configs.go#L68-L84>)

ConnectionDetails holds configuration settings for the database connection pool. These settings help optimize performance and resource usage by controlling how database connections are created, reused, and expired.

```go
type ConnectionDetails struct {
    // MaxOpenConns controls the maximum number of open connections to the database.
    // Setting this appropriately helps prevent overwhelming the database with too many connections.
    // Default is 0 (unlimited).
    MaxOpenConns int

    // MaxIdleConns controls the maximum number of connections in the idle connection pool.
    // A higher value can improve performance under a concurrent load but consumes more resources.
    // Default is 2.
    MaxIdleConns int

    // ConnMaxLifetime is the maximum amount of time a connection may be reused.
    // Expired connections are closed and removed from the pool during connection acquisition.
    // This helps ensure database-enforced timeouts are respected.
    // Default is 0 (unlimited).
    ConnMaxLifetime time.Duration
}
```

<a name="ErrorCategory"></a>
## type [ErrorCategory](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/errors.go#L464>)

ErrorCategory represents different categories of database errors

```go
type ErrorCategory int
```

<a name="CategoryUnknown"></a>

```go
const (
    CategoryUnknown ErrorCategory = iota
    CategoryConnection
    CategoryQuery
    CategoryData
    CategoryConstraint
    CategoryPermission
    CategoryTransaction
    CategoryResource
    CategorySystem
    CategorySchema
    CategoryOperation
)
```

<a name="MariaDB"></a>
## type [MariaDB](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/setup.go#L18-L27>)

MariaDB is a thread\-safe wrapper around gorm.DB that provides connection monitoring, automatic reconnection, and standardized database operations for MariaDB/MySQL. It guards all database operations with a mutex to ensure thread safety and includes mechanisms for graceful shutdown and connection health monitoring.

```go
type MariaDB struct {
    Client *gorm.DB
    // contains filtered or unexported fields
}
```

<a name="NewMariaDB"></a>
### func [NewMariaDB](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/setup.go#L33>)

```go
func NewMariaDB(cfg Config) (*MariaDB, error)
```

NewMariaDB creates a new MariaDB instance with the provided configuration. It establishes the initial database connection and sets up the internal state for connection monitoring and recovery. If the initial connection fails, it returns an error.

<a name="NewMariaDBClientWithDI"></a>
### func [NewMariaDBClientWithDI](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/fx_module.go#L58>)

```go
func NewMariaDBClientWithDI(params MariaDBParams) (*MariaDB, error)
```

NewMariaDBClientWithDI creates a new MariaDB Client using dependency injection. This function is designed to be used with Uber's fx dependency injection framework where the Config dependency is automatically provided via the MariaDBParams struct.

Parameters:

- params: A MariaDBParams struct containing the Config instance required to initialize the MariaDB Client. This struct embeds fx.In to enable automatic injection of these dependencies.

Returns:

- \*MariaDB: A fully initialized MariaDB Client ready for use.

Example usage with fx:

```
app := fx.New(
    mariadb.FXModule,
    fx.Provide(
        func() mariadb.Config {
            return loadMariaDBConfig() // Your config loading function
        },
    ),
)
```

This function delegates to the standard NewMariaDB function, maintaining the same initialization logic while enabling seamless integration with dependency injection.

<a name="MariaDB.AutoMigrate"></a>
### func \(\*MariaDB\) [AutoMigrate](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/migrations.go#L99>)

```go
func (p *MariaDB) AutoMigrate(models ...interface{}) error
```

AutoMigrate is a wrapper around GORM's AutoMigrate with additional features. It tracks migrations in the migration history table and provides better error handling.

Parameters:

- models: The GORM models to auto\-migrate

Returns a GORM error if any part of the migration process fails.

This method is useful during development or for simple applications, but for production systems, explicit migrations are recommended.

<a name="MariaDB.Count"></a>
### func \(\*MariaDB\) [Count](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/basic_ops.go#L273>)

```go
func (m *MariaDB) Count(ctx context.Context, model interface{}, count *int64, conditions ...interface{}) error
```

Count determines the number of records that match the given conditions. It populates the count parameter with the result.

Parameters:

- ctx: Context for the database operation
- model: The model type to count
- count: Pointer to an int64 where the count will be stored
- conditions: Query conditions to filter the records to count

Returns a GORM error if the query fails or nil on success. Use TranslateError\(\) to convert to standardized error types if needed.

Example:

```
var count int64
err := db.Count(ctx, &User{}, &count, "age > ?", 18)
```

<a name="MariaDB.Create"></a>
### func \(\*MariaDB\) [Create](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/basic_ops.go#L69>)

```go
func (m *MariaDB) Create(ctx context.Context, value interface{}) error
```

Create inserts a new record into the database. It processes the value parameter according to GORM conventions, performing hooks and validations defined on the model.

Parameters:

- ctx: Context for the database operation
- value: The struct or slice of structs to be created

Returns a GORM error if the creation fails or nil on success. Use TranslateError\(\) to convert to standardized error types if needed.

Example:

```
user := User{Name: "John", Email: "john@example.com"}
err := db.Create(ctx, &user)
```

<a name="MariaDB.CreateMigration"></a>
### func \(\*MariaDB\) [CreateMigration](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/migrations.go#L454>)

```go
func (p *MariaDB) CreateMigration(migrationsDir, name string, migrationType MigrationType) (string, error)
```

CreateMigration generates a new migration file. It creates both up and down migration files with appropriate names and timestamps.

Parameters:

- migrationsDir: Directory where migration files should be created
- name: Descriptive name for the migration
- migrationType: Whether this is a schema or data migration

Returns the base filename of the created migration or a wrapped error if creation fails.

Example:

```
filename, err := db.CreateMigration("./migrations", "create_users_table", mariadb.SchemaType)
if err == nil {
    fmt.Printf("Created migration: %s\n", filename)
}
```

<a name="MariaDB.DB"></a>
### func \(\*MariaDB\) [DB](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/utils.go#L14>)

```go
func (m *MariaDB) DB() *gorm.DB
```

DB returns the underlying GORM DB Client instance. This method provides direct access to the database connection while maintaining thread safety through a read lock.

Use this method when you need to perform operations not covered by the wrapper methods or when you need to access specific GORM functionality. Note that direct usage bypasses some of the safety mechanisms, so use it with care.

<a name="MariaDB.Delete"></a>
### func \(\*MariaDB\) [Delete](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/basic_ops.go#L218>)

```go
func (m *MariaDB) Delete(ctx context.Context, value interface{}, conditions ...interface{}) (int64, error)
```

Delete removes records that match the given value and conditions from the database. It respects soft delete if implemented on the model.

Parameters:

- ctx: Context for the database operation
- value: The model to delete or a slice for batch delete
- conditions: Additional conditions to filter records to delete

Returns:

- int64: Number of rows affected by the delete operation
- error: GORM error if the deletion fails, nil on success

Example:

```
// Delete user with ID=1
rowsAffected, err := db.Delete(ctx, &User{}, "id = ?", 1)
if err != nil {
    return err
}
fmt.Printf("Deleted %d rows\n", rowsAffected)

// Or with a model instance
user := User{ID: 1}
rowsAffected, err := db.Delete(ctx, &user)
```

<a name="MariaDB.Exec"></a>
### func \(\*MariaDB\) [Exec](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/basic_ops.go#L248>)

```go
func (m *MariaDB) Exec(ctx context.Context, sql string, values ...interface{}) (int64, error)
```

Exec executes raw SQL directly against the database. This is useful for operations not easily expressed through GORM's API or for performance\-critical code.

Parameters:

- ctx: Context for the database operation
- sql: The SQL statement to execute
- values: Parameters for the SQL statement

Returns:

- int64: Number of rows affected by the SQL execution
- error: GORM error if the execution fails, nil on success

Example:

```
rowsAffected, err := db.Exec(ctx, "UPDATE users SET status = ? WHERE last_login < ?",
                             "inactive", time.Now().AddDate(0, -6, 0))
if err != nil {
    return err
}
fmt.Printf("Updated %d users\n", rowsAffected)
```

<a name="MariaDB.Find"></a>
### func \(\*MariaDB\) [Find](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/basic_ops.go#L22>)

```go
func (m *MariaDB) Find(ctx context.Context, dest interface{}, conditions ...interface{}) error
```

Find retrieves records from the database that match the given conditions. It populates the dest parameter with the query results.

Parameters:

- ctx: Context for the database operation
- dest: Pointer to a slice where the results will be stored
- conditions: Optional query conditions \(follows GORM conventions\)

Returns a GORM error if the query fails or nil on success. Use TranslateError\(\) to convert to standardized error types if needed.

Example:

```
var users []User
err := db.Find(ctx, &users, "name LIKE ?", "%john%")
```

<a name="MariaDB.First"></a>
### func \(\*MariaDB\) [First](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/basic_ops.go#L47>)

```go
func (m *MariaDB) First(ctx context.Context, dest interface{}, conditions ...interface{}) error
```

First retrieves the first record that matches the given conditions. It populates the dest parameter with the result or returns an error if no matching record exists.

Parameters:

- ctx: Context for the database operation
- dest: Pointer to a struct where the result will be stored
- conditions: Optional query conditions \(follows GORM conventions\)

Returns gorm.ErrRecordNotFound if no matching record exists, or another GORM error if the query fails. Use TranslateError\(\) to convert to standardized error types if needed.

Example:

```
var user User
err := db.First(ctx, &user, "email = ?", "user@example.com")
if errors.Is(err, gorm.ErrRecordNotFound) {
    // Handle not found
}
```

<a name="MariaDB.GetErrorCategory"></a>
### func \(\*MariaDB\) [GetErrorCategory](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/errors.go#L481>)

```go
func (m *MariaDB) GetErrorCategory(err error) ErrorCategory
```

GetErrorCategory returns the category of the given error

<a name="MariaDB.GetMigrationStatus"></a>
### func \(\*MariaDB\) [GetMigrationStatus](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/migrations.go#L388>)

```go
func (p *MariaDB) GetMigrationStatus(ctx context.Context, migrationsDir string) ([]map[string]interface{}, error)
```

GetMigrationStatus returns the status of all migrations. It compares available migrations with those that have been applied to build a comprehensive status report.

Parameters:

- ctx: Context for database operations
- migrationsDir: Directory containing the migration SQL files

Returns a slice of maps with status information for each migration, or a wrapped error if the status cannot be determined. The error wraps the underlying GORM error with additional context.

Example:

```
status, err := db.GetMigrationStatus(ctx, "./migrations")
if err == nil {
    for _, m := range status {
        fmt.Printf("Migration %s: %v\n", m["id"], m["applied"])
    }
}
```

<a name="MariaDB.GracefulShutdown"></a>
### func \(\*MariaDB\) [GracefulShutdown](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/fx_module.go#L127>)

```go
func (m *MariaDB) GracefulShutdown() error
```



<a name="MariaDB.IsCritical"></a>
### func \(\*MariaDB\) [IsCritical](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/errors.go#L554>)

```go
func (m *MariaDB) IsCritical(err error) bool
```

IsCritical returns true if the error indicates a serious system problem

<a name="MariaDB.IsRetryable"></a>
### func \(\*MariaDB\) [IsRetryable](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/errors.go#L509>)

```go
func (m *MariaDB) IsRetryable(err error) bool
```

IsRetryable returns true if the error might be resolved by retrying the operation

<a name="MariaDB.IsTemporary"></a>
### func \(\*MariaDB\) [IsTemporary](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/errors.go#L533>)

```go
func (m *MariaDB) IsTemporary(err error) bool
```

IsTemporary returns true if the error is likely temporary and might resolve itself

<a name="MariaDB.MigrateDown"></a>
### func \(\*MariaDB\) [MigrateDown](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/migrations.go#L251>)

```go
func (p *MariaDB) MigrateDown(ctx context.Context, migrationsDir string) error
```

MigrateDown rolls back the last applied migration. It finds the most recently applied migration and executes its corresponding down migration to revert the changes.

Parameters:

- ctx: Context for database operations
- migrationsDir: Directory containing the migration SQL files

Returns a wrapped error if the rollback fails or if the down migration can't be found. The error wraps the underlying GORM error with additional context.

Example:

```
err := db.MigrateDown(ctx, "./migrations")
```

<a name="MariaDB.MigrateUp"></a>
### func \(\*MariaDB\) [MigrateUp](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/migrations.go#L152>)

```go
func (p *MariaDB) MigrateUp(ctx context.Context, migrationsDir string) error
```

MigrateUp applies all pending migrations from the specified directory. It identifies which migrations haven't been applied yet, sorts them by ID, and applies them in order within transactions.

Parameters:

- ctx: Context for database operations
- migrationsDir: Directory containing the migration SQL files

Returns a wrapped error if any migration fails or if there are issues accessing the migrations. The error wraps the underlying GORM error with additional context.

Example:

```
err := db.MigrateUp(ctx, "./migrations")
```

<a name="MariaDB.MonitorConnection"></a>
### func \(\*MariaDB\) [MonitorConnection](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/setup.go#L184>)

```go
func (m *MariaDB) MonitorConnection(ctx context.Context)
```

MonitorConnection periodically checks the health of the database connection and triggers reconnection attempts when necessary. It runs as a goroutine that performs health checks at regular intervals \(10 seconds\) and signals the RetryConnection goroutine when a failure is detected.

The function respects context cancellation and shutdown signals, ensuring proper resource cleanup and graceful termination when requested.

<a name="MariaDB.Query"></a>
### func \(\*MariaDB\) [Query](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L34>)

```go
func (m *MariaDB) Query(ctx context.Context) *QueryBuilder
```

Query provides a flexible way to build complex queries. It returns a QueryBuilder which can be used to chain query methods in a fluent interface. The method acquires a read lock on the database connection that will be automatically released when a terminal method is called or Done\(\) is invoked.

Parameters:

- ctx: Context for the database operation

Returns a QueryBuilder instance that can be used to construct the query.

Note: QueryBuilder methods return GORM errors directly. Use MariaDB.TranslateError\(\) to convert them to standardized error types if needed.

Example:

```
users := []User{}
err := db.Query(ctx).
    Where("age > ?", 18).
    Order("created_at DESC").
    Limit(10).
    Find(&users)
if err != nil {
    err = db.TranslateError(err) // Optional: translate to standardized error
}
```

<a name="MariaDB.RetryConnection"></a>
### func \(\*MariaDB\) [RetryConnection](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/setup.go#L142>)

```go
func (m *MariaDB) RetryConnection(ctx context.Context)
```

RetryConnection continuously attempts to reconnect to the MariaDB database when notified of a connection failure. It operates as a goroutine that waits for signals on retryChanSignal before attempting reconnection. The function respects context cancellation and shutdown signals, ensuring graceful termination when requested.

It implements two nested loops: \- The outer loop waits for retry signals \- The inner loop attempts reconnection until successful

<a name="MariaDB.Save"></a>
### func \(\*MariaDB\) [Save](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/basic_ops.go#L91>)

```go
func (m *MariaDB) Save(ctx context.Context, value interface{}) error
```

Save updates the database record if the primary key exists, otherwise it creates a new record. It performs a full update of all fields, not just changed fields.

Parameters:

- ctx: Context for the database operation
- value: The struct to be saved

Returns a GORM error if the operation fails or nil on success. Use TranslateError\(\) to convert to standardized error types if needed.

Example:

```
user.Name = "Updated Name"
err := db.Save(ctx, &user)
```

<a name="MariaDB.Transaction"></a>
### func \(\*MariaDB\) [Transaction](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/transactions.go#L41>)

```go
func (m *MariaDB) Transaction(ctx context.Context, fn func(db *MariaDB) error) error
```

Transaction executes the given function within a database transaction. It creates a transaction\-specific MariaDB instance and passes it to the provided function. If the function returns an error, the transaction is rolled back; otherwise, it's committed.

This method provides a clean way to execute multiple database operations as a single atomic unit, with automatic handling of commit/rollback based on the execution result.

Returns a GORM error if the transaction fails or the error returned by the callback function.

Example usage:

```
err := db.Transaction(ctx, func(txDB *MariaDB) error {
	if err := txDB.Create(ctx, user); err != nil {
		return err
	}
	return txDB.Create(ctx, userProfile)
})
```

<a name="MariaDB.TranslateError"></a>
### func \(\*MariaDB\) [TranslateError](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/errors.go#L169>)

```go
func (m *MariaDB) TranslateError(err error) error
```

TranslateError converts GORM/database\-specific errors into standardized application errors. This function provides abstraction from the underlying database implementation details, allowing application code to handle errors in a database\-agnostic way.

It maps common database errors to the standardized error types defined above. If an error doesn't match any known type, it's returned unchanged.

<a name="MariaDB.Update"></a>
### func \(\*MariaDB\) [Update](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/basic_ops.go#L122>)

```go
func (m *MariaDB) Update(ctx context.Context, model interface{}, attrs interface{}) (int64, error)
```

Update updates records that match the given model's non\-zero fields or primary key. It only updates the fields provided in attrs and only affects records that match the model's primary key or query conditions.

Parameters:

- ctx: Context for the database operation
- model: The model instance with primary key set, or struct with query conditions
- attrs: Map, struct, or individual field values to update

Returns:

- int64: Number of rows affected by the update operation
- error: GORM error if the update fails, nil on success

Example:

```
// Update user with ID=1
rowsAffected, err := db.Update(ctx, &User{ID: 1}, map[string]interface{}{
    "name": "New Name",
    "age": 30,
})
if err != nil {
    return err
}
fmt.Printf("Updated %d rows\n", rowsAffected)
```

<a name="MariaDB.UpdateColumn"></a>
### func \(\*MariaDB\) [UpdateColumn](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/basic_ops.go#L153>)

```go
func (m *MariaDB) UpdateColumn(ctx context.Context, model interface{}, columnName string, value interface{}) (int64, error)
```

UpdateColumn updates a single column's value for records that match the given model. Unlike Update, it doesn't run hooks and can be used to update fields that are zero values \(like setting a string to empty or a number to zero\).

Parameters:

- ctx: Context for the database operation
- model: The model instance with primary key set, or struct with query conditions
- columnName: Name of the column to update
- value: New value for the column

Returns:

- int64: Number of rows affected by the update operation
- error: GORM error if the update fails, nil on success

Example:

```
// Set status to "inactive" for user with ID=1
rowsAffected, err := db.UpdateColumn(ctx, &User{ID: 1}, "status", "inactive")
if err != nil {
    return err
}
fmt.Printf("Updated %d rows\n", rowsAffected)
```

<a name="MariaDB.UpdateColumns"></a>
### func \(\*MariaDB\) [UpdateColumns](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/basic_ops.go#L185>)

```go
func (m *MariaDB) UpdateColumns(ctx context.Context, model interface{}, columnValues map[string]interface{}) (int64, error)
```

UpdateColumns updates multiple columns with name/value pairs for records that match the given model. Like UpdateColumn, it doesn't run hooks and can update zero\-value fields.

Parameters:

- ctx: Context for the database operation
- model: The model instance with primary key set, or struct with query conditions
- columnValues: Map of column names to their new values

Returns:

- int64: Number of rows affected by the update operation
- error: GORM error if the update fails, nil on success

Example:

```
// Update multiple fields for user with ID=1
rowsAffected, err := db.UpdateColumns(ctx, &User{ID: 1}, map[string]interface{}{
    "status": "inactive",
    "last_login": time.Now(),
})
if err != nil {
    return err
}
fmt.Printf("Updated %d rows\n", rowsAffected)
```

<a name="MariaDB.UpdateWhere"></a>
### func \(\*MariaDB\) [UpdateWhere](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/basic_ops.go#L305>)

```go
func (m *MariaDB) UpdateWhere(ctx context.Context, model interface{}, attrs interface{}, condition string, args ...interface{}) (int64, error)
```

UpdateWhere updates records that match the specified WHERE condition. This method provides more flexibility than Update for complex conditions.

Parameters:

- ctx: Context for the database operation
- model: The model type to update
- attrs: Fields to update \(map, struct, or name/value pairs\)
- condition: WHERE condition as a string
- args: Arguments for the WHERE condition

Returns:

- int64: Number of rows affected by the update operation
- error: GORM error if the update fails, nil on success

Example:

```
// Update all users who haven't logged in for 6 months
rowsAffected, err := db.UpdateWhere(ctx, &User{},
                                    map[string]interface{}{"status": "inactive"},
                                    "last_login < ?",
                                    time.Now().AddDate(0, -6, 0))
if err != nil {
    return err
}
fmt.Printf("Updated %d users to inactive status\n", rowsAffected)
```

<a name="MariaDBLifeCycleParams"></a>
## type [MariaDBLifeCycleParams](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/fx_module.go#L69-L74>)

MariaDBLifeCycleParams groups the dependencies needed for MariaDB lifecycle management. This struct combines all the components required to properly manage the lifecycle of a MariaDB Client within an fx application, including startup, monitoring, and graceful shutdown.

The embedded fx.In marker enables automatic injection of the struct fields from the dependency container when this struct is used as a parameter in lifecycle registration functions.

```go
type MariaDBLifeCycleParams struct {
    fx.In

    Lifecycle fx.Lifecycle
    MariaDB   *MariaDB
}
```

<a name="MariaDBParams"></a>
## type [MariaDBParams](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/fx_module.go#L27-L31>)

MariaDBParams groups the dependencies needed to create a MariaDB Client via dependency injection. This struct is designed to work with Uber's fx dependency injection framework and provides the necessary parameters for initializing a MariaDB database connection.

The embedded fx.In marker enables automatic injection of the struct fields from the dependency container when this struct is used as a parameter in provider functions.

```go
type MariaDBParams struct {
    fx.In

    Config Config
}
```

<a name="Migration"></a>
## type [Migration](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/migrations.go#L42-L58>)

Migration represents a single database migration with all its metadata and content. Each migration contains the SQL to execute and information about its purpose and identity.

```go
type Migration struct {
    // ID is a unique identifier for the migration, typically a timestamp (YYYYMMDDHHMMSS)
    // that also helps establish the execution order.
    ID  string

    // Name is a descriptive label for the migration, typically describing what it does.
    Name string

    // Type categorizes the migration as either schema or data.
    Type MigrationType

    // Direction indicates whether this is an up (apply) or down (rollback) migration.
    Direction MigrationDirection

    // SQL contains the actual SQL statements to execute for this migration.
    SQL string
}
```

<a name="MigrationDirection"></a>
## type [MigrationDirection](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/migrations.go#L30>)

MigrationDirection specifies the direction of the migration, indicating whether it's applying a change or reverting one.

```go
type MigrationDirection string
```

<a name="UpMigration"></a>

```go
const (
    // UpMigration indicates a forward migration that applies a change.
    UpMigration MigrationDirection = "up"

    // DownMigration indicates a rollback migration that reverts a change.
    DownMigration MigrationDirection = "down"
)
```

<a name="MigrationHistoryRecord"></a>
## type [MigrationHistoryRecord](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/migrations.go#L63-L87>)

MigrationHistoryRecord represents a record in the migration history table. It tracks when and how each migration was applied, enabling the system to determine which migrations have been run and providing an audit trail.

```go
type MigrationHistoryRecord struct {
    // ID matches the migration ID that was applied.
    ID  string

    // Name is the descriptive name of the migration.
    Name string

    // Type indicates whether this was a schema or data migration.
    Type string

    // ExecutedAt records when the migration was applied.
    ExecutedAt time.Time

    // ExecutedBy tracks who or what system applied the migration.
    ExecutedBy string

    // Duration measures how long the migration took to execute in milliseconds.
    Duration int64

    // Status indicates whether the migration completed successfully or failed.
    Status string

    // ErrorMessage contains details if the migration failed.
    ErrorMessage string `gorm:"type:text"`
}
```

<a name="MigrationType"></a>
## type [MigrationType](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/migrations.go#L16>)

MigrationType defines the type of migration, categorizing the purpose of the change. This helps track and organize migrations based on their impact on the database.

```go
type MigrationType string
```

<a name="SchemaType"></a>

```go
const (
    // SchemaType represents schema changes (tables, columns, indexes, etc.)
    // These migrations modify the structure of the database.
    SchemaType MigrationType = "schema"

    // DataType represents data manipulations (inserts, updates, etc.)
    // These migrations modify the content within the database.
    DataType MigrationType = "data"
)
```

<a name="QueryBuilder"></a>
## type [QueryBuilder](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L49-L55>)

QueryBuilder provides a fluent interface for building complex database queries. It wraps GORM's query building capabilities with thread\-safety and automatic resource cleanup. The builder maintains a chain of query modifiers that are applied when a terminal method is called.

Note: All terminal methods \(First, Find, Create, etc.\) return GORM errors directly. This preserves the error chain and allows consumers to use errors.Is\(\) with GORM error types. Use MariaDB.TranslateError\(\) to convert errors to standardized types if needed.

```go
type QueryBuilder struct {
    // contains filtered or unexported fields
}
```

<a name="QueryBuilder.Clauses"></a>
### func \(\*QueryBuilder\) [Clauses](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L684>)

```go
func (qb *QueryBuilder) Clauses(conds ...clause.Expression) *QueryBuilder
```

Clauses adds custom clauses to the query. This is a generic method for adding any GORM clause type.

Parameters:

- conds: One or more clause expressions

Returns the QueryBuilder for method chaining.

Example:

```
qb.Clauses(clause.OrderBy{
    Expression: clause.Expr{SQL: "RAND()"},
}).Find(&users) // Random order (MySQL uses RAND())

qb.Clauses(clause.GroupBy{
    Columns: []clause.Column{{Name: "department"}},
}).Find(&users)
```

<a name="QueryBuilder.Count"></a>
### func \(\*QueryBuilder\) [Count](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L400>)

```go
func (qb *QueryBuilder) Count(count *int64) error
```

Count counts records that match the query conditions. This is a terminal method that executes the query and releases the mutex lock.

Parameters:

- count: Pointer to an int64 where the count will be stored

Returns a GORM error if the query fails or nil on success.

Example:

```
var count int64
err := qb.Where("active = ?", true).Count(&count)
```

<a name="QueryBuilder.Create"></a>
### func \(\*QueryBuilder\) [Create](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L715>)

```go
func (qb *QueryBuilder) Create(value interface{}) (int64, error)
```

Create inserts a new record into the database. This is a terminal method that executes the operation and releases the mutex lock. It can be combined with OnConflict\(\) for UPSERT operations and other query builder methods.

Parameters:

- value: Pointer to the struct or slice of structs to create

Returns:

- int64: Number of rows affected \(records created\)
- error: GORM error if the operation fails, nil on success

Example:

```
user := User{Name: "John", Email: "john@example.com"}
rowsAffected, err := qb.Create(&user)
if err != nil {
    return err
}
fmt.Printf("Created %d record, ID: %d\n", rowsAffected, user.ID)
```

With OnConflict for idempotent create:

```
rowsAffected, err := qb.OnConflict(clause.OnConflict{DoNothing: true}).Create(&stage)
if rowsAffected == 0 {
    // Record already exists
}
```

<a name="QueryBuilder.CreateInBatches"></a>
### func \(\*QueryBuilder\) [CreateInBatches](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L742>)

```go
func (qb *QueryBuilder) CreateInBatches(value interface{}, batchSize int) (int64, error)
```

CreateInBatches creates records in batches to avoid memory issues with large datasets. This is a terminal method that executes the operation and releases the mutex lock.

Parameters:

- value: Slice of records to create
- batchSize: Number of records to process in each batch

Returns:

- int64: Number of rows affected \(records created\)
- error: GORM error if the operation fails, nil on success

Example:

```
users := []User{{Name: "John"}, {Name: "Jane"}, {Name: "Bob"}}
rowsAffected, err := qb.CreateInBatches(&users, 100)
if err != nil {
    return err
}
fmt.Printf("Created %d records\n", rowsAffected)
```

<a name="QueryBuilder.Delete"></a>
### func \(\*QueryBuilder\) [Delete](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L447>)

```go
func (qb *QueryBuilder) Delete(value interface{}) (int64, error)
```

Delete deletes records that match the query conditions. This is a terminal method that executes the query and releases the mutex lock.

Parameters:

- value: Model value or pointer to specify what to delete

Returns:

- int64: Number of rows affected by the delete operation
- error: GORM error if the deletion fails, nil on success

Example:

```
rowsAffected, err := qb.Where("created_at < ?", time.Now().AddDate(-1, 0, 0)).Delete(&User{})
if err != nil {
    return err
}
fmt.Printf("Deleted %d rows\n", rowsAffected)
```

<a name="QueryBuilder.Distinct"></a>
### func \(\*QueryBuilder\) [Distinct](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L494>)

```go
func (qb *QueryBuilder) Distinct(args ...interface{}) *QueryBuilder
```

Distinct specifies that the query should return distinct results. It eliminates duplicate rows from the result set.

Parameters:

- args: Optional columns to apply DISTINCT to

Returns the QueryBuilder for method chaining.

Example:

```
qb.Distinct("department").Find(&departments)
qb.Distinct().Where("age > ?", 18).Find(&users) // SELECT DISTINCT * FROM users WHERE age > 18
```

<a name="QueryBuilder.Done"></a>
### func \(\*QueryBuilder\) [Done](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L798>)

```go
func (qb *QueryBuilder) Done()
```

Done releases the mutex lock without executing the query. This method should be called when you want to cancel a query building chain without executing any terminal operation.

Example:

```
qb := db.Query(ctx)
if someCondition {
    err := qb.Where(...).Find(&results)
} else {
    qb.Done() // Release the lock without executing
}
```

<a name="QueryBuilder.Find"></a>
### func \(\*QueryBuilder\) [Find](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L344>)

```go
func (qb *QueryBuilder) Find(dest interface{}) error
```

Find finds records that match the query conditions. This is a terminal method that executes the query and releases the mutex lock.

Parameters:

- dest: Pointer to a slice where results will be stored

Returns a GORM error if the query fails or nil on success. Use MariaDB.TranslateError\(\) to convert to standardized error types.

Example:

```
var users []User
err := qb.Where("active = ?", true).Find(&users)
```

<a name="QueryBuilder.First"></a>
### func \(\*QueryBuilder\) [First](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L365>)

```go
func (qb *QueryBuilder) First(dest interface{}) error
```

First finds the first record that matches the query conditions. This is a terminal method that executes the query and releases the mutex lock.

Parameters:

- dest: Pointer to a struct where the result will be stored

Returns gorm.ErrRecordNotFound if no record is found, or another GORM error if the query fails, nil on success. Use MariaDB.TranslateError\(\) to convert to standardized error types if needed.

Example:

```
var user User
err := qb.Where("email = ?", "user@example.com").First(&user)
if err != nil {
    err = db.TranslateError(err) // Optional: convert to standardized error
}
```

<a name="QueryBuilder.FirstOrCreate"></a>
### func \(\*QueryBuilder\) [FirstOrCreate](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L781>)

```go
func (qb *QueryBuilder) FirstOrCreate(dest interface{}, conds ...interface{}) error
```

FirstOrCreate finds the first record matching the conditions, or creates a new one if not found. This is a terminal method.

Parameters:

- dest: Pointer to the struct where the result will be stored
- conds: Optional conditions for the query

Returns a GORM error if the operation fails or nil on success.

Example:

```
var user User
err := qb.Where("email = ?", "user@example.com").FirstOrCreate(&user)
```

<a name="QueryBuilder.FirstOrInit"></a>
### func \(\*QueryBuilder\) [FirstOrInit](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L763>)

```go
func (qb *QueryBuilder) FirstOrInit(dest interface{}, conds ...interface{}) error
```

FirstOrInit finds the first record matching the conditions, or initializes a new one if not found. This is a terminal method.

Parameters:

- dest: Pointer to the struct where the result will be stored
- conds: Optional conditions for the query

Returns a GORM error if the operation fails or nil on success.

Example:

```
var user User
err := qb.Where("email = ?", "user@example.com").FirstOrInit(&user)
```

<a name="QueryBuilder.ForShare"></a>
### func \(\*QueryBuilder\) [ForShare](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L586>)

```go
func (qb *QueryBuilder) ForShare() *QueryBuilder
```

ForShare adds a FOR SHARE clause to the query for shared row\-level locking. This allows other transactions to read the rows but prevents them from updating or deleting until the current transaction commits or rolls back.

Note: MySQL/MariaDB uses LOCK IN SHARE MODE for this functionality.

Returns the QueryBuilder for method chaining.

Example:

```
qb.Where("id = ?", userID).ForShare().First(&user) // Shared lock for reading
qb.ForShare().Where("status = ?", "active").Find(&users) // Prevents updates but allows reads
```

<a name="QueryBuilder.ForShareSkipLocked"></a>
### func \(\*QueryBuilder\) [ForShareSkipLocked](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L621>)

```go
func (qb *QueryBuilder) ForShareSkipLocked() *QueryBuilder
```

ForShareSkipLocked adds a FOR SHARE SKIP LOCKED clause to the query. This acquires shared locks but skips any rows that are already exclusively locked.

Note: Requires MySQL 8.0\+ or MariaDB 10.6\+

Returns the QueryBuilder for method chaining.

Example:

```
qb.Where("category = ?", "news").ForShareSkipLocked().Find(&articles)
```

<a name="QueryBuilder.ForUpdate"></a>
### func \(\*QueryBuilder\) [ForUpdate](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L569>)

```go
func (qb *QueryBuilder) ForUpdate() *QueryBuilder
```

ForUpdate adds a FOR UPDATE clause to the query for exclusive row\-level locking. This prevents other transactions from modifying the selected rows until the current transaction commits or rolls back.

Returns the QueryBuilder for method chaining.

Example:

```
qb.Where("id = ?", userID).ForUpdate().First(&user) // Locks the row for update
qb.ForUpdate().Where("status = ?", "pending").Find(&orders) // Locks all matching rows
```

<a name="QueryBuilder.ForUpdateNoWait"></a>
### func \(\*QueryBuilder\) [ForUpdateNoWait](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L640>)

```go
func (qb *QueryBuilder) ForUpdateNoWait() *QueryBuilder
```

ForUpdateNoWait adds a FOR UPDATE NOWAIT clause to the query. This attempts to acquire exclusive locks but immediately fails if any target rows are already locked, instead of waiting.

Note: Requires MySQL 8.0\+ or MariaDB 10.3\+

Returns the QueryBuilder for method chaining.

Example:

```
qb.Where("id = ?", accountID).ForUpdateNoWait().First(&account)
```

<a name="QueryBuilder.ForUpdateSkipLocked"></a>
### func \(\*QueryBuilder\) [ForUpdateSkipLocked](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L603>)

```go
func (qb *QueryBuilder) ForUpdateSkipLocked() *QueryBuilder
```

ForUpdateSkipLocked adds a FOR UPDATE SKIP LOCKED clause to the query. This acquires exclusive locks but skips any rows that are already locked, making it ideal for job queue processing where you want to avoid blocking.

Note: Requires MySQL 8.0\+ or MariaDB 10.6\+

Returns the QueryBuilder for method chaining.

Example:

```
qb.Where("status = ?", "pending").ForUpdateSkipLocked().Limit(10).Find(&jobs)
qb.ForUpdateSkipLocked().Where("processed = ?", false).First(&task)
```

<a name="QueryBuilder.Group"></a>
### func \(\*QueryBuilder\) [Group](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L210>)

```go
func (qb *QueryBuilder) Group(query string) *QueryBuilder
```

Group adds a GROUP BY clause to the query. It is used to group rows with the same values into summary rows.

Parameters:

- query: GROUP BY expression

Returns the QueryBuilder for method chaining.

Example:

```
qb.Group("status")
qb.Group("department, location")
```

<a name="QueryBuilder.Having"></a>
### func \(\*QueryBuilder\) [Having](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L227>)

```go
func (qb *QueryBuilder) Having(query interface{}, args ...interface{}) *QueryBuilder
```

Having added a HAVING clause to the query. It is used to filter groups created by the GROUP BY clause.

Parameters:

- query: HAVING condition with optional placeholders
- args: Arguments for any placeholders in the query

Returns the QueryBuilder for method chaining.

Example:

```
qb.Group("department").Having("COUNT(*) > ?", 3)
```

<a name="QueryBuilder.Joins"></a>
### func \(\*QueryBuilder\) [Joins](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L139>)

```go
func (qb *QueryBuilder) Joins(query string, args ...interface{}) *QueryBuilder
```

Joins add a JOIN clause to the query. It performs an INNER JOIN by default.

Parameters:

- query: JOIN condition string
- args: Arguments for any placeholders in the query

Returns the QueryBuilder for method chaining.

Example:

```
qb.Joins("JOIN orders ON orders.user_id = users.id")
```

<a name="QueryBuilder.Last"></a>
### func \(\*QueryBuilder\) [Last](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L383>)

```go
func (qb *QueryBuilder) Last(dest interface{}) error
```

Last finds the last record that matches the query conditions. This is a terminal method that executes the query and releases the mutex lock.

Parameters:

- dest: Pointer to a struct where the result will be stored

Returns gorm.ErrRecordNotFound if no record is found, or another GORM error if the query fails, nil on success. Use MariaDB.TranslateError\(\) to convert to standardized error types if needed.

Example:

```
var user User
err := qb.Where("department = ?", "Engineering").Order("joined_at ASC").Last(&user)
```

<a name="QueryBuilder.LeftJoin"></a>
### func \(\*QueryBuilder\) [LeftJoin](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L156>)

```go
func (qb *QueryBuilder) LeftJoin(query string, args ...interface{}) *QueryBuilder
```

LeftJoin adds a LEFT JOIN clause to the query. It retrieves all records from the left table and matching records from the right table.

Parameters:

- query: JOIN condition string without the "LEFT JOIN" prefix
- args: Arguments for any placeholders in the query

Returns the QueryBuilder for method chaining.

Example:

```
qb.LeftJoin("orders ON orders.user_id = users.id")
```

<a name="QueryBuilder.Limit"></a>
### func \(\*QueryBuilder\) [Limit](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L259>)

```go
func (qb *QueryBuilder) Limit(limit int) *QueryBuilder
```

Limit sets the maximum number of records to return.

Parameters:

- limit: Maximum number of records

Returns the QueryBuilder for method chaining.

Example:

```
qb.Limit(10) // Return at most 10 records
```

<a name="QueryBuilder.MapRows"></a>
### func \(\*QueryBuilder\) [MapRows](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/row_scanner.go#L72>)

```go
func (qb *QueryBuilder) MapRows(destSlice interface{}, mapFn func(*gorm.DB) error) error
```

MapRows executes a query and maps all rows into a destination slice using the provided mapping function. This provides a higher\-level abstraction than working with raw rows, allowing for custom mapping logic while still handling the query execution and resource management automatically.

Parameters:

- destSlice: The slice to populate with mapped rows \(should be a pointer to a slice\)
- mapFn: A function that defines how to map rows from the database to your slice items

Returns a GORM error if the mapping fails or nil on success.

<a name="QueryBuilder.Model"></a>
### func \(\*QueryBuilder\) [Model](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L308>)

```go
func (qb *QueryBuilder) Model(value interface{}) *QueryBuilder
```

Model specifies the model to use for the query. This is useful when the model can't be inferred from other methods.

Parameters:

- value: Pointer to the model struct or its instance

Returns the QueryBuilder for method chaining.

Example:

```
qb.Model(&User{}).Where("active = ?", true).Count(&count)
```

<a name="QueryBuilder.Not"></a>
### func \(\*QueryBuilder\) [Not](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L122>)

```go
func (qb *QueryBuilder) Not(query interface{}, args ...interface{}) *QueryBuilder
```

Not adds a NOT condition to the query. It negates the specified condition.

Parameters:

- query: Condition string with optional placeholders or a map of conditions
- args: Arguments for any placeholders in the query

Returns the QueryBuilder for method chaining.

Example:

```
qb.Not("status = ?", "deleted")
```

<a name="QueryBuilder.Offset"></a>
### func \(\*QueryBuilder\) [Offset](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L275>)

```go
func (qb *QueryBuilder) Offset(offset int) *QueryBuilder
```

Offset sets the number of records to skip. It is typically used with Limit for pagination.

Parameters:

- offset: Number of records to skip

Returns the QueryBuilder for method chaining.

Example:

```
qb.Offset(20).Limit(10) // Skip 20 records and return the next 10
```

<a name="QueryBuilder.OnConflict"></a>
### func \(\*QueryBuilder\) [OnConflict](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L662>)

```go
func (qb *QueryBuilder) OnConflict(onConflict clause.OnConflict) *QueryBuilder
```

OnConflict adds an ON DUPLICATE KEY UPDATE clause for UPSERT operations. This handles conflicts during INSERT operations by updating existing records.

Parameters:

- onConflict: ON CONFLICT clause configuration

Returns the QueryBuilder for method chaining.

Example:

```
qb.OnConflict(clause.OnConflict{
    Columns:   []clause.Column{{Name: "email"}},
    DoUpdates: clause.AssignmentColumns([]string{"name", "updated_at"}),
}).Create(&user)
```

<a name="QueryBuilder.Or"></a>
### func \(\*QueryBuilder\) [Or](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L105>)

```go
func (qb *QueryBuilder) Or(query interface{}, args ...interface{}) *QueryBuilder
```

Or adds an OR condition to the query. It combines with previous conditions using OR logic.

Parameters:

- query: Condition string with optional placeholders or a map of conditions
- args: Arguments for any placeholders in the query

Returns the QueryBuilder for method chaining.

Example:

```
qb.Where("status = ?", "active").Or("status = ?", "pending")
```

<a name="QueryBuilder.Order"></a>
### func \(\*QueryBuilder\) [Order](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L244>)

```go
func (qb *QueryBuilder) Order(value interface{}) *QueryBuilder
```

Order adds an ORDER BY clause to the query. It is used to sort the result set.

Parameters:

- value: ORDER BY expression

Returns the QueryBuilder for method chaining.

Example:

```
qb.Order("created_at DESC")
qb.Order("age ASC, name DESC")
```

<a name="QueryBuilder.Pluck"></a>
### func \(\*QueryBuilder\) [Pluck](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L474>)

```go
func (qb *QueryBuilder) Pluck(column string, dest interface{}) (int64, error)
```

Pluck queries a single column and scans the results into a slice. This is a terminal method that executes the query and releases the mutex lock.

Parameters:

- column: Name of the column to query
- dest: Pointer to a slice where results will be stored

Returns:

- int64: Number of rows found and processed
- error: GORM error if the query fails, nil on success

Example:

```
var emails []string
rowsFound, err := qb.Where("department = ?", "Engineering").Pluck("email", &emails)
if err != nil {
    return err
}
fmt.Printf("Found %d email addresses\n", rowsFound)
```

<a name="QueryBuilder.Preload"></a>
### func \(\*QueryBuilder\) [Preload](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L193>)

```go
func (qb *QueryBuilder) Preload(query string, args ...interface{}) *QueryBuilder
```

Preload preloads associations for the query results. This is used to eagerly load related models to avoid N\+1 query problems.

Parameters:

- query: Name of the association to preload
- args: Optional conditions for the preloaded association

Return the QueryBuilder for method chaining.

Example:

```
qb.Preload("Orders")
qb.Preload("Orders", "state = ?", "paid")
```

<a name="QueryBuilder.QueryRow"></a>
### func \(\*QueryBuilder\) [QueryRow](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/row_scanner.go#L36>)

```go
func (qb *QueryBuilder) QueryRow() RowScanner
```

QueryRow executes a query expected to return a single row and returns a RowScanner for it. This method is optimized for queries that return exactly one row of data and provides a simplified interface for scanning the values from that row.

<a name="QueryBuilder.QueryRows"></a>
### func \(\*QueryBuilder\) [QueryRows](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/row_scanner.go#L46>)

```go
func (qb *QueryBuilder) QueryRows() (RowsScanner, error)
```

QueryRows executes a query that returns multiple rows and returns a RowsScanner for them. This method provides an iterator\-style interface for processing multiple rows returned by a query, allowing for efficient traversal of large result sets.

Returns a RowsScanner and a GORM error if the query fails.

<a name="QueryBuilder.Raw"></a>
### func \(\*QueryBuilder\) [Raw](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L292>)

```go
func (qb *QueryBuilder) Raw(sql string, values ...interface{}) *QueryBuilder
```

Raw executes raw SQL as part of the query. It provides full SQL flexibility when needed.

Parameters:

- SQL: Raw SQL statement with optional placeholders
- values: Arguments for any placeholders in the SQL

Returns the QueryBuilder for method chaining.

Example:

```
qb.Raw("SELECT * FROM users WHERE created_at > ?", time.Now().AddDate(0, -1, 0))
```

<a name="QueryBuilder.RightJoin"></a>
### func \(\*QueryBuilder\) [RightJoin](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L174>)

```go
func (qb *QueryBuilder) RightJoin(query string, args ...interface{}) *QueryBuilder
```

RightJoin adds a RIGHT JOIN clause to the query. It retrieves all records from the right table and matching records from the left table.

Parameters:

- query: JOIN condition string without the "RIGHT JOIN" prefix
- args: Arguments for any placeholders in the query

Returns the QueryBuilder for method chaining.

Example:

```
qb.RightJoin("orders ON orders.user_id = users.id")
```

<a name="QueryBuilder.Scan"></a>
### func \(\*QueryBuilder\) [Scan](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L326>)

```go
func (qb *QueryBuilder) Scan(dest interface{}) error
```

Scan scans the result into the destination struct or slice. This is a terminal method that executes the query and releases the mutex lock.

Parameters:

- dest: Pointer to the struct or slice where results will be stored

Returns a GORM error if the query fails or nil on success. Use MariaDB.TranslateError\(\) to convert to standardized error types.

Example:

```
var result struct{ Count int }
err := qb.Raw("SELECT COUNT(*) as count FROM users").Scan(&result)
```

<a name="QueryBuilder.ScanRow"></a>
### func \(\*QueryBuilder\) [ScanRow](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/row_scanner.go#L57>)

```go
func (qb *QueryBuilder) ScanRow(dest interface{}) error
```

ScanRow is a convenience method to scan a single row directly into a struct. This is a higher\-level alternative to QueryRow that automatically maps column values to struct fields based on naming conventions or field tags. It's useful when you need to map a row to a predefined data structure.

Returns a GORM error if the scan fails or nil on success.

<a name="QueryBuilder.Scopes"></a>
### func \(\*QueryBuilder\) [Scopes](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L554>)

```go
func (qb *QueryBuilder) Scopes(funcs ...func(*gorm.DB) *gorm.DB) *QueryBuilder
```

Scopes applies one or more scopes to the query. Scopes are reusable query conditions that can be applied to multiple queries.

Parameters:

- funcs: One or more scope functions that modify the query

Returns the QueryBuilder for method chaining.

Example:

```
// Define scopes
func ActiveUsers(db *gorm.DB) *gorm.DB {
    return db.Where("active = ?", true)
}
func AdultUsers(db *gorm.DB) *gorm.DB {
    return db.Where("age >= ?", 18)
}

// Use scopes
qb.Scopes(ActiveUsers, AdultUsers).Find(&users)
qb.Scopes(ActiveUsers).Count(&count)
```

<a name="QueryBuilder.Select"></a>
### func \(\*QueryBuilder\) [Select](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L70>)

```go
func (qb *QueryBuilder) Select(query interface{}, args ...interface{}) *QueryBuilder
```

Select specifies fields to be selected in the query. It corresponds to the SQL SELECT clause.

Parameters:

- query: Field selection string or raw SQL expression
- args: Arguments for any placeholders in the query

Returns the QueryBuilder for method chaining.

Example:

```
qb.Select("id, name, email")
qb.Select("COUNT(*) as user_count")
```

<a name="QueryBuilder.Table"></a>
### func \(\*QueryBuilder\) [Table](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L512>)

```go
func (qb *QueryBuilder) Table(name string) *QueryBuilder
```

Table specifies the table name for the query. This overrides the default table name derived from the model.

Parameters:

- name: Table name to use for the query

Returns the QueryBuilder for method chaining.

Example:

```
qb.Table("users_archive").Where("deleted_at IS NOT NULL").Find(&users)
qb.Table("custom_table_name").Count(&count)
qb.Table("user_stats").Select("department, COUNT(*) as count").Group("department").Scan(&stats)
```

<a name="QueryBuilder.ToSubquery"></a>
### func \(\*QueryBuilder\) [ToSubquery](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L838>)

```go
func (qb *QueryBuilder) ToSubquery() *gorm.DB
```

ToSubquery returns the underlying GORM DB for use as a subquery and releases the lock. This method is specifically designed for creating subqueries that can be passed to Where\(\), Having\(\), or other clauses that accept subqueries.

Important: This method releases the lock immediately, so the returned \*gorm.DB should be used as a subquery argument right away.

Returns:

- \*gorm.DB: The underlying GORM DB instance configured with the query chain

Example:

```
// Find users whose email is in a subquery of active accounts
activeEmails := db.Query(ctx).
    Model(&Account{}).
    Select("email").
    Where("status = ?", "active").
    ToSubquery()

var users []User
err := db.Query(ctx).
    Where("email IN (?)", activeEmails).
    Find(&users)
```

Complex example with multiple subqueries:

```
// Find stages with no files
stageIDsWithFiles := db.Query(ctx).
    Model(&File{}).
    Select("DISTINCT stage_id").
    ToSubquery()

err := db.Query(ctx).
    Model(&Stage{}).
    Where("stage_id NOT IN (?)", stageIDsWithFiles).
    Find(&stages)
```

<a name="QueryBuilder.Unscoped"></a>
### func \(\*QueryBuilder\) [Unscoped](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L528>)

```go
func (qb *QueryBuilder) Unscoped() *QueryBuilder
```

Unscoped disables the default scope for the query. This allows querying soft\-deleted records or bypassing other default scopes. Commonly used with GORM's soft delete feature.

Returns the QueryBuilder for method chaining.

Example:

```
qb.Unscoped().Where("name = ?", "John").Find(&users) // Includes soft-deleted records
qb.Unscoped().Delete(&user) // Permanently deletes the record
qb.Unscoped().Count(&count) // Counts all records including soft-deleted
```

<a name="QueryBuilder.Updates"></a>
### func \(\*QueryBuilder\) [Updates](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L422>)

```go
func (qb *QueryBuilder) Updates(values interface{}) (int64, error)
```

Updates updates records that match the query conditions. This is a terminal method that executes the query and releases the mutex lock.

Parameters:

- values: Map or struct with the fields to update

Returns:

- int64: Number of rows affected by the update operation
- error: GORM error if the update fails, nil on success

Example:

```
rowsAffected, err := qb.Where("expired = ?", true).Updates(map[string]interface{}{"active": false})
if err != nil {
    return err
}
fmt.Printf("Updated %d rows\n", rowsAffected)
```

<a name="QueryBuilder.Where"></a>
### func \(\*QueryBuilder\) [Where](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/query_builder.go#L88>)

```go
func (qb *QueryBuilder) Where(query interface{}, args ...interface{}) *QueryBuilder
```

Where adds a WHERE condition to the query. Multiple Where calls are combined with AND logic.

Parameters:

- query: Condition string with optional placeholders or a map of conditions
- args: Arguments for any placeholders in the query

Returns the QueryBuilder for method chaining.

Example:

```
qb.Where("age > ?", 18)
qb.Where("status = ?", "active")
```

<a name="RowScanner"></a>
## type [RowScanner](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/row_scanner.go#L10-L14>)

RowScanner provides an interface for scanning a single row of data. It abstracts the process of parsing column values into Go variables, allowing for efficient handling of individual rows returned from a query.

```go
type RowScanner interface {
    // Scan copies the column values from the current row into the values pointed to by dest.
    // The number of values in dest must match the number of columns in the row.
    Scan(dest ...interface{}) error
}
```

<a name="RowsScanner"></a>
## type [RowsScanner](<https://github.com/Aleph-Alpha/std/blob/main/v1/mariadb/row_scanner.go#L19-L31>)

RowsScanner provides an interface for iterating through rows of data returned by a query. It extends RowScanner functionality with methods for navigation and error handling, allowing for efficient processing of result sets with multiple rows.

```go
type RowsScanner interface {
    // Next prepares the next row for reading. It returns false when there are no more rows.
    Next() bool

    // Scan copies column values from the current row into the provided destination variables.
    Scan(dest ...interface{}) error

    // Close closes the rows iterator, releasing any associated resources.
    Close() error

    // Err returns any error encountered during iteration.
    Err() error
}
```

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
