<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# tracer

```go
import "gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/pkg/tracer"
```

Package tracer provides a simple, consistent API for distributed tracing in Go applications using OpenTelemetry standards. It handles span creation, propagation, attribute management, and trace exporting with minimal configuration.

The package includes:

- Simple span creation and management
- Error recording and status tracking
- Automatic trace context propagation across service boundaries
- Flexible attribute recording with type support
- Integration with Uber FX for dependency injection

### Basic Usage

Initialize the tracer:

```
cfg := tracer.Config{
    ServiceName: "user-service",
    AppEnv: "production",
    EnableExport: true,
}
tracerClient := tracer.NewClient(cfg, logger)
```

Create spans for operations:

```
ctx, span := tracerClient.StartSpan(ctx, "fetch-user-data")
defer span.End()
```

Record errors when they occur:

```
if err != nil {
    tracerClient.RecordErrorOnSpan(span, err)
    return nil, err
}
```

Add attributes to provide context:

```
tracerClient.SetAttributes(span, map[string]interface{}{
    "user.id": userID,
    "request.size": size,
    "cache.hit": true,
})
```

### Distributed Tracing

For outgoing requests, extract trace context:

```
headers := tracerClient.GetCarrier(ctx)
// Add headers to outgoing HTTP request or message
```

For incoming requests, import trace context:

```
// Extract headers from incoming HTTP request or message
ctx = tracerClient.SetCarrierOnContext(ctx, headers)
```

### Uber FX Integration

To use with Uber FX, import the module in your application:

```
app := fx.New(
    tracer.FXModule,
    // other modules...
)
```

This will automatically set up the tracer and manage its lifecycle.

### Best Practices

1. Always end spans with defer span.End\(\) 2. Create spans for significant operations, not every function call 3. Add attributes that provide business context to aid troubleshooting 4. Propagate context through your call stack to maintain the trace 5. Record errors on spans to correlate exceptions with traces

Package tracer is a generated GoMock package.

## Index

- [Variables](<#variables>)
- [func RegisterTracerLifecycle\(lc fx.Lifecycle, tracer \*Tracer\)](<#RegisterTracerLifecycle>)
- [type Config](<#Config>)
- [type Logger](<#Logger>)
- [type MockLogger](<#MockLogger>)
  - [func NewMockLogger\(ctrl \*gomock.Controller\) \*MockLogger](<#NewMockLogger>)
  - [func \(m \*MockLogger\) Debug\(msg string, err error, fields ...map\[string\]any\)](<#MockLogger.Debug>)
  - [func \(m \*MockLogger\) EXPECT\(\) \*MockLoggerMockRecorder](<#MockLogger.EXPECT>)
  - [func \(m \*MockLogger\) Error\(msg string, err error, fields ...map\[string\]any\)](<#MockLogger.Error>)
  - [func \(m \*MockLogger\) Fatal\(msg string, err error, fields ...map\[string\]any\)](<#MockLogger.Fatal>)
  - [func \(m \*MockLogger\) Info\(msg string, err error, fields ...map\[string\]any\)](<#MockLogger.Info>)
  - [func \(m \*MockLogger\) Warn\(msg string, err error, fields ...map\[string\]any\)](<#MockLogger.Warn>)
- [type MockLoggerMockRecorder](<#MockLoggerMockRecorder>)
  - [func \(mr \*MockLoggerMockRecorder\) Debug\(msg, err any, fields ...any\) \*gomock.Call](<#MockLoggerMockRecorder.Debug>)
  - [func \(mr \*MockLoggerMockRecorder\) Error\(msg, err any, fields ...any\) \*gomock.Call](<#MockLoggerMockRecorder.Error>)
  - [func \(mr \*MockLoggerMockRecorder\) Fatal\(msg, err any, fields ...any\) \*gomock.Call](<#MockLoggerMockRecorder.Fatal>)
  - [func \(mr \*MockLoggerMockRecorder\) Info\(msg, err any, fields ...any\) \*gomock.Call](<#MockLoggerMockRecorder.Info>)
  - [func \(mr \*MockLoggerMockRecorder\) Warn\(msg, err any, fields ...any\) \*gomock.Call](<#MockLoggerMockRecorder.Warn>)
- [type Tracer](<#Tracer>)
  - [func NewClient\(cfg Config, logger Logger\) \*Tracer](<#NewClient>)
  - [func \(t \*Tracer\) GetCarrier\(ctx context.Context\) map\[string\]string](<#Tracer.GetCarrier>)
  - [func \(t \*Tracer\) RecordErrorOnSpan\(span traceSpan.Span, err error\)](<#Tracer.RecordErrorOnSpan>)
  - [func \(t \*Tracer\) SetAttributes\(span traceSpan.Span, attrs map\[string\]interface\{\}\)](<#Tracer.SetAttributes>)
  - [func \(t \*Tracer\) SetCarrierOnContext\(ctx context.Context, carrier map\[string\]string\) context.Context](<#Tracer.SetCarrierOnContext>)
  - [func \(t \*Tracer\) StartSpan\(ctx context.Context, name string\) \(context.Context, traceSpan.Span\)](<#Tracer.StartSpan>)


## Variables

<a name="FXModule"></a>FXModule provides a Uber FX module that configures distributed tracing for your application. This module registers the tracer client with the dependency injection system and sets up proper lifecycle management to ensure graceful startup and shutdown of the tracer.

The module: 1. Provides the tracer client through the NewClient constructor 2. Registers shutdown hooks to cleanly close tracer resources on application termination

Usage:

```
app := fx.New(
    tracer.FXModule,
    // other modules...
)
app.Run()
```

This module should be included in your main application to enable distributed tracing throughout your dependency graph without manual wiring.

```go
var FXModule = fx.Module("tracer",
    fx.Provide(
        NewClient,
    ),
    fx.Invoke(RegisterTracerLifecycle),
)
```

<a name="RegisterTracerLifecycle"></a>
## func [RegisterTracerLifecycle](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/tracer/fx_module.go#L57>)

```go
func RegisterTracerLifecycle(lc fx.Lifecycle, tracer *Tracer)
```

RegisterTracerLifecycle registers shutdown hooks for the tracer with the FX lifecycle. This function ensures that tracer resources are properly released when the application terminates, preventing resource leaks and ensuring traces are flushed to exporters.

Parameters:

- lc: The FX lifecycle to register hooks with
- tracer: The tracer instance to manage lifecycle for

The function registers an OnStop hook that: 1. Logs that the tracer is shutting down 2. Gracefully shuts down the tracer provider 3. Handles edge cases where the tracer might be nil

This function is automatically invoked by the FXModule and normally doesn't need to be called directly.

Example of how this works in the FX application lifecycle:

```
app := fx.New(
    tracer.FXModule,
    // When app.Stop() is called or the application receives a termination signal:
    // 1. The OnStop hook registered by RegisterTracerLifecycle is called
    // 2. The tracer is gracefully shut down, flushing any pending spans
)
```

<a name="Config"></a>
## type [Config](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/tracer/configs.go#L6-L34>)

Config defines the configuration for the OpenTelemetry tracer. It controls service identification, environment settings, and whether traces should be exported to an observability backend.

```go
type Config struct {
    // ServiceName specifies the name of the service using this tracer.
    // This field is required and will appear in traces to identify the service
    // that generated the spans. It should be a descriptive, stable name that
    // uniquely identifies your service in your system architecture.
    //
    // Example values: "user-service", "payment-processor", "notification-worker"
    ServiceName string

    // AppEnv indicates the deployment environment where the service is running.
    // This helps separate traces from different environments in your observability system.
    // Common values include "development", "staging", "production".
    //
    // This field is used to set the "deployment.environment" and "environment"
    // resource attributes on all spans.
    AppEnv string

    // EnableExport controls whether traces are exported to an observability backend.
    // When set to true, the tracer will configure an OTLP HTTP exporter to send
    // traces to a collector. When false, traces are only kept in memory and not exported.
    //
    // In development environments, you might set this to false to avoid unnecessary
    // traffic to your observability system. In production, this should typically be
    // set to true to capture all telemetry data.
    //
    // Note that even when this is false, tracing is still functional for request context
    // propagation; spans just won't be sent to external systems.
    EnableExport bool
}
```

<a name="Logger"></a>
## type [Logger](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/tracer/setup.go#L20-L26>)

Logger defines the interface for logging operations in the rabbit package. This interface allows the package to use any logging implementation that conforms to these methods.

```go
type Logger interface {
    Info(msg string, err error, fields ...map[string]interface{})
    Debug(msg string, err error, fields ...map[string]interface{})
    Warn(msg string, err error, fields ...map[string]interface{})
    Error(msg string, err error, fields ...map[string]interface{})
    Fatal(msg string, err error, fields ...map[string]interface{})
}
```

<a name="MockLogger"></a>
## type [MockLogger](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/tracer/mock_logger.go#L19-L23>)

MockLogger is a mock of Logger interface.

```go
type MockLogger struct {
    // contains filtered or unexported fields
}
```

<a name="NewMockLogger"></a>
### func [NewMockLogger](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/tracer/mock_logger.go#L31>)

```go
func NewMockLogger(ctrl *gomock.Controller) *MockLogger
```

NewMockLogger creates a new mock instance.

<a name="MockLogger.Debug"></a>
### func \(\*MockLogger\) [Debug](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/tracer/mock_logger.go#L43>)

```go
func (m *MockLogger) Debug(msg string, err error, fields ...map[string]any)
```

Debug mocks base method.

<a name="MockLogger.EXPECT"></a>
### func \(\*MockLogger\) [EXPECT](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/tracer/mock_logger.go#L38>)

```go
func (m *MockLogger) EXPECT() *MockLoggerMockRecorder
```

EXPECT returns an object that allows the caller to indicate expected use.

<a name="MockLogger.Error"></a>
### func \(\*MockLogger\) [Error](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/tracer/mock_logger.go#L60>)

```go
func (m *MockLogger) Error(msg string, err error, fields ...map[string]any)
```

Error mocks base method.

<a name="MockLogger.Fatal"></a>
### func \(\*MockLogger\) [Fatal](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/tracer/mock_logger.go#L77>)

```go
func (m *MockLogger) Fatal(msg string, err error, fields ...map[string]any)
```

Fatal mocks base method.

<a name="MockLogger.Info"></a>
### func \(\*MockLogger\) [Info](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/tracer/mock_logger.go#L94>)

```go
func (m *MockLogger) Info(msg string, err error, fields ...map[string]any)
```

Info mocks base method.

<a name="MockLogger.Warn"></a>
### func \(\*MockLogger\) [Warn](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/tracer/mock_logger.go#L111>)

```go
func (m *MockLogger) Warn(msg string, err error, fields ...map[string]any)
```

Warn mocks base method.

<a name="MockLoggerMockRecorder"></a>
## type [MockLoggerMockRecorder](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/tracer/mock_logger.go#L26-L28>)

MockLoggerMockRecorder is the mock recorder for MockLogger.

```go
type MockLoggerMockRecorder struct {
    // contains filtered or unexported fields
}
```

<a name="MockLoggerMockRecorder.Debug"></a>
### func \(\*MockLoggerMockRecorder\) [Debug](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/tracer/mock_logger.go#L53>)

```go
func (mr *MockLoggerMockRecorder) Debug(msg, err any, fields ...any) *gomock.Call
```

Debug indicates an expected call of Debug.

<a name="MockLoggerMockRecorder.Error"></a>
### func \(\*MockLoggerMockRecorder\) [Error](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/tracer/mock_logger.go#L70>)

```go
func (mr *MockLoggerMockRecorder) Error(msg, err any, fields ...any) *gomock.Call
```

Error indicates an expected call of Error.

<a name="MockLoggerMockRecorder.Fatal"></a>
### func \(\*MockLoggerMockRecorder\) [Fatal](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/tracer/mock_logger.go#L87>)

```go
func (mr *MockLoggerMockRecorder) Fatal(msg, err any, fields ...any) *gomock.Call
```

Fatal indicates an expected call of Fatal.

<a name="MockLoggerMockRecorder.Info"></a>
### func \(\*MockLoggerMockRecorder\) [Info](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/tracer/mock_logger.go#L104>)

```go
func (mr *MockLoggerMockRecorder) Info(msg, err any, fields ...any) *gomock.Call
```

Info indicates an expected call of Info.

<a name="MockLoggerMockRecorder.Warn"></a>
### func \(\*MockLoggerMockRecorder\) [Warn](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/tracer/mock_logger.go#L121>)

```go
func (mr *MockLoggerMockRecorder) Warn(msg, err any, fields ...any) *gomock.Call
```

Warn indicates an expected call of Warn.

<a name="Tracer"></a>
## type [Tracer](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/tracer/setup.go#L42-L45>)

Tracer provides a simplified API for distributed tracing with OpenTelemetry. It wraps the OpenTelemetry TracerProvider and provides convenient methods for creating spans, recording errors, and propagating trace context across service boundaries.

Tracer handles the complexity of trace context propagation, span creation, and attribute management, making it easier to implement distributed tracing in your applications.

To use Tracer effectively: 1. Create spans for significant operations in your code 2. Record errors when operations fail 3. Add attributes to spans to provide context 4. Extract and inject trace context when crossing service boundaries

The Tracer is designed to be thread\-safe and can be shared across goroutines.

```go
type Tracer struct {
    // contains filtered or unexported fields
}
```

<a name="NewClient"></a>
### func [NewClient](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/tracer/setup.go#L79>)

```go
func NewClient(cfg Config, logger Logger) *Tracer
```

NewClient creates and initializes a new Tracer instance with OpenTelemetry. This function sets up the OpenTelemetry tracer provider with the provided configuration, configures trace exporters if enabled, and sets global OpenTelemetry settings.

Parameters:

- cfg: Configuration for the tracer, including service name, environment, and export settings
- logger: Logger for recording initialization events and errors

Returns:

- \*Tracer: A configured Tracer instance ready for creating spans and managing trace context

If trace export is enabled in the configuration, this function will set up an OTLP HTTP exporter that sends traces to the configured endpoint. If export fails to initialize, it will log a fatal error.

The function also configures resource attributes for the service, including:

- Service name
- Deployment environment
- Environment tag

Example:

```
cfg := tracer.Config{
    ServiceName: "user-service",
    AppEnv: "production",
    EnableExport: true,
}

tracerClient := tracer.NewClient(cfg, logger)

// Use the tracer in your application
ctx, span := tracerClient.StartSpan(context.Background(), "process-request")
defer span.End()
```

<a name="Tracer.GetCarrier"></a>
### func \(\*Tracer\) [GetCarrier](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/tracer/utils.go#L173>)

```go
func (t *Tracer) GetCarrier(ctx context.Context) map[string]string
```

GetCarrier extracts the current trace context from a context object and returns it as a map that can be transmitted across service boundaries. This is essential for distributed tracing to maintain trace continuity across different services.

The returned map contains W3C Trace Context headers that follow the standard format for distributed tracing, making it compatible with other services that support the W3C Trace Context specification.

Parameters:

- ctx: The context containing the current trace information

Returns:

- map\[string\]string: A map containing the trace context headers

The returned map typically includes:

- "traceparent": Contains trace ID, span ID, and trace flags
- "tracestate": Contains vendor\-specific trace information \(if present\)

Example:

```
// Extract trace context for an outgoing HTTP request
func makeHttpRequest(ctx context.Context, url string) (*http.Response, error) {
    req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
    if err != nil {
        return nil, err
    }

    // Get trace headers from context
    traceHeaders := tracer.GetCarrier(ctx)

    // Add trace headers to the outgoing request
    for key, value := range traceHeaders {
        req.Header.Set(key, value)
    }

    // Make the request with trace context included
    return http.DefaultClient.Do(req)
}
```

<a name="Tracer.RecordErrorOnSpan"></a>
### func \(\*Tracer\) [RecordErrorOnSpan](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/tracer/utils.go#L33>)

```go
func (t *Tracer) RecordErrorOnSpan(span traceSpan.Span, err error)
```

RecordErrorOnSpan records an error on a span and sets its status to error. This method is used to indicate that a span represents a failed operation, which helps with error tracing and monitoring in observability systems.

Parameters:

- span: The span on which to record the error
- err: The error to record on the span

Example:

```
ctx, span := tracer.StartSpan(ctx, "fetch-user-data")
defer span.End()

data, err := fetchUserData(ctx, userID)
if err != nil {
    // Record the error on the span to track it in traces
    tracer.RecordErrorOnSpan(span, err)
    return nil, err
}

return data, nil
```

<a name="Tracer.SetAttributes"></a>
### func \(\*Tracer\) [SetAttributes](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/tracer/utils.go#L107>)

```go
func (t *Tracer) SetAttributes(span traceSpan.Span, attrs map[string]interface{})
```

SetAttributes adds one or more attributes to a span with support for different data types. Attributes provide additional context and metadata for spans, making traces more informative for debugging and analysis.

Parameters:

- span: The span to add attributes to
- attrs: A map of attribute keys to values. Values can be strings, ints, int64s, float64s, or booleans. Other types are converted to strings.

Supported value types:

- string: Stored as string attributes
- int/int64: Stored as integer attributes
- float64: Stored as floating\-point attributes
- bool: Stored as boolean attributes
- other types: Converted to strings using fmt.Sprint

Example:

```
ctx, span := tracer.StartSpan(ctx, "process-payment")
defer span.End()

// Add attributes to provide context about the operation
tracer.SetAttributes(span, map[string]interface{}{
    "user.id": userID,
    "payment.amount": amount,
    "payment.currency": "USD",
    "payment.method": "credit_card",
    "request.id": requestID,
})

// Perform the payment processing...
```

<a name="Tracer.SetCarrierOnContext"></a>
### func \(\*Tracer\) [SetCarrierOnContext](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/tracer/utils.go#L217>)

```go
func (t *Tracer) SetCarrierOnContext(ctx context.Context, carrier map[string]string) context.Context
```

SetCarrierOnContext extracts trace information from a carrier map and injects it into a context. This is the complement to GetCarrier and is typically used when receiving requests or messages from other services that include trace headers.

This method is crucial for maintaining distributed trace continuity across service boundaries by ensuring that spans created in this service are properly connected to spans from upstream services.

Parameters:

- ctx: The base context to inject trace information into
- carrier: A map containing trace headers \(like those from HTTP requests or message headers\)

Returns:

- context.Context: A new context with the trace information from the carrier injected into it

The carrier map typically contains the following trace context headers:

- "traceparent": Contains trace ID, span ID, and trace flags
- "tracestate": Contains vendor\-specific trace information \(if present\)

Example:

```
// Extract trace context from an incoming HTTP request
func httpHandler(w http.ResponseWriter, r *http.Request) {
    // Extract headers from the request
    headers := make(map[string]string)
    for key, values := range r.Header {
        if len(values) > 0 {
            headers[key] = values[0]
        }
    }

    // Create a context with the trace information
    ctx := tracer.SetCarrierOnContext(r.Context(), headers)

    // Use this traced context for processing the request
    result, err := processRequest(ctx, r)
    // ...
}
```

<a name="Tracer.StartSpan"></a>
### func \(\*Tracer\) [StartSpan](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/tracer/utils.go#L70>)

```go
func (t *Tracer) StartSpan(ctx context.Context, name string) (context.Context, traceSpan.Span)
```

StartSpan creates a new span with the given name and returns an updated context containing the span, along with the span itself. This is the primary method for creating spans to trace operations in your application.

The created span becomes a child of any span that exists in the provided context. If no span exists in the context, a new root span is created.

Parameters:

- ctx: The parent context, which may contain a parent span
- name: A descriptive name for the operation being traced

Returns:

- context.Context: A new context containing the created span
- traceSpan.Span: The created span, which must be ended when the operation completes

Example:

```
func processRequest(ctx context.Context, req Request) (Response, error) {
    // Create a span for this operation
    ctx, span := tracer.StartSpan(ctx, "process-request")
    // Ensure the span is ended when the function returns
    defer span.End()

    // Perform the operation, using the context with the span
    result, err := performWork(ctx, req)
    if err != nil {
        tracer.RecordErrorOnSpan(span, err)
        return Response{}, err
    }

    return result, nil
}
```

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
