<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# postgres

```go
import "gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/pkg/postgres"
```

Package postgres provides functionality for interacting with PostgreSQL databases.

The postgres package offers a robust interface for working with PostgreSQL databases, built on top of the standard database/sql package. It includes connection management, query execution, transaction handling, and migration tools.

Core Features:

- Connection pooling and management
- Parameterized query execution
- Transaction support with automatic rollback on errors
- Schema migration tools
- Row scanning utilities
- Basic CRUD operations

Basic Usage:

```
import (
	"gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/pkg/postgres"
	"gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/pkg/logger"
)

// Create a logger
log, _ := logger.NewLogger(logger.Config{Level: "info"})

// Create a new database connection
db, err := postgres.New(postgres.Config{
	Host:     "localhost",
	Port:     5432,
	Username: "postgres",
	Password: "password",
	Database: "mydb",
}, log)
if err != nil {
	log.Fatal("Failed to connect to database", err, nil)
}
defer db.Close()

// Execute a query
rows, err := db.Query(context.Background(), "SELECT id, name FROM users WHERE age > $1", 18)
if err != nil {
	log.Error("Query failed", err, nil)
}
defer rows.Close()

// Scan the results
var users []User
for rows.Next() {
	var user User
	if err := rows.Scan(&user.ID, &user.Name); err != nil {
		log.Error("Scan failed", err, nil)
	}
	users = append(users, user)
}
```

Transaction Example:

```
err = db.WithTransaction(context.Background(), func(tx postgres.Transaction) error {
	// Execute multiple queries in a transaction
	_, err := tx.Exec("UPDATE accounts SET balance = balance - $1 WHERE id = $2", amount, fromID)
	if err != nil {
		return err  // Transaction will be rolled back
	}

	_, err = tx.Exec("UPDATE accounts SET balance = balance + $1 WHERE id = $2", amount, toID)
	if err != nil {
		return err  // Transaction will be rolled back
	}

	return nil  // Transaction will be committed
})
```

Basic Operations:

```
// Create a record
id, err := db.Insert(ctx, "INSERT INTO users(name, email) VALUES($1, $2) RETURNING id", "John", "john@example.com")

// Check if a record exists
exists, err := db.Exists(ctx, "SELECT 1 FROM users WHERE email = $1", "john@example.com")

// Get a single record
var user User
err = db.Get(ctx, &user, "SELECT id, name, email FROM users WHERE id = $1", id)
```

FX Module Integration:

This package provides an fx module for easy integration:

```
app := fx.New(
	logger.Module,
	postgres.Module,
	// ... other modules
)
app.Run()
```

Performance Considerations:

- Connection pooling is automatically handled to optimize performance
- Prepared statements are used internally to reduce parsing overhead
- Consider using batch operations for multiple insertions
- Query timeouts are recommended for all database operations

Thread Safety:

All methods on the DB interface are safe for concurrent use by multiple goroutines.

Package postgres is a generated GoMock package.

## Index

- [Variables](<#variables>)
- [func RegisterPostgresLifecycle\(params PostgresLifeCycleParams\)](<#RegisterPostgresLifecycle>)
- [func TranslateError\(err error\) error](<#TranslateError>)
- [type Config](<#Config>)
- [type Connection](<#Connection>)
- [type ConnectionDetails](<#ConnectionDetails>)
- [type Logger](<#Logger>)
- [type Migration](<#Migration>)
- [type MigrationDirection](<#MigrationDirection>)
- [type MigrationHistoryRecord](<#MigrationHistoryRecord>)
- [type MigrationType](<#MigrationType>)
- [type MockLogger](<#MockLogger>)
  - [func NewMockLogger\(ctrl \*gomock.Controller\) \*MockLogger](<#NewMockLogger>)
  - [func \(m \*MockLogger\) Debug\(msg string, err error, fields ...map\[string\]any\)](<#MockLogger.Debug>)
  - [func \(m \*MockLogger\) EXPECT\(\) \*MockLoggerMockRecorder](<#MockLogger.EXPECT>)
  - [func \(m \*MockLogger\) Error\(msg string, err error, fields ...map\[string\]any\)](<#MockLogger.Error>)
  - [func \(m \*MockLogger\) Fatal\(msg string, err error, fields ...map\[string\]any\)](<#MockLogger.Fatal>)
  - [func \(m \*MockLogger\) Info\(msg string, err error, fields ...map\[string\]any\)](<#MockLogger.Info>)
  - [func \(m \*MockLogger\) Warn\(msg string, err error, fields ...map\[string\]any\)](<#MockLogger.Warn>)
- [type MockLoggerMockRecorder](<#MockLoggerMockRecorder>)
  - [func \(mr \*MockLoggerMockRecorder\) Debug\(msg, err any, fields ...any\) \*gomock.Call](<#MockLoggerMockRecorder.Debug>)
  - [func \(mr \*MockLoggerMockRecorder\) Error\(msg, err any, fields ...any\) \*gomock.Call](<#MockLoggerMockRecorder.Error>)
  - [func \(mr \*MockLoggerMockRecorder\) Fatal\(msg, err any, fields ...any\) \*gomock.Call](<#MockLoggerMockRecorder.Fatal>)
  - [func \(mr \*MockLoggerMockRecorder\) Info\(msg, err any, fields ...any\) \*gomock.Call](<#MockLoggerMockRecorder.Info>)
  - [func \(mr \*MockLoggerMockRecorder\) Warn\(msg, err any, fields ...any\) \*gomock.Call](<#MockLoggerMockRecorder.Warn>)
- [type Postgres](<#Postgres>)
  - [func NewPostgres\(cfg Config, logger Logger\) \*Postgres](<#NewPostgres>)
  - [func NewPostgresClientWithDI\(params PostgresParams\) \*Postgres](<#NewPostgresClientWithDI>)
  - [func \(p \*Postgres\) AutoMigrate\(models ...interface\{\}\) error](<#Postgres.AutoMigrate>)
  - [func \(p \*Postgres\) Count\(ctx context.Context, model interface\{\}, count \*int64, conditions ...interface\{\}\) error](<#Postgres.Count>)
  - [func \(p \*Postgres\) Create\(ctx context.Context, value interface\{\}\) error](<#Postgres.Create>)
  - [func \(p \*Postgres\) CreateMigration\(migrationsDir, name string, migrationType MigrationType\) \(string, error\)](<#Postgres.CreateMigration>)
  - [func \(p \*Postgres\) DB\(\) \*gorm.DB](<#Postgres.DB>)
  - [func \(p \*Postgres\) Delete\(ctx context.Context, value interface\{\}, conditions ...interface\{\}\) error](<#Postgres.Delete>)
  - [func \(p \*Postgres\) Exec\(ctx context.Context, sql string, values ...interface\{\}\) error](<#Postgres.Exec>)
  - [func \(p \*Postgres\) Find\(ctx context.Context, dest interface\{\}, conditions ...interface\{\}\) error](<#Postgres.Find>)
  - [func \(p \*Postgres\) First\(ctx context.Context, dest interface\{\}, conditions ...interface\{\}\) error](<#Postgres.First>)
  - [func \(p \*Postgres\) GetMigrationStatus\(ctx context.Context, migrationsDir string\) \(\[\]map\[string\]interface\{\}, error\)](<#Postgres.GetMigrationStatus>)
  - [func \(p \*Postgres\) GracefulShutdown\(\) error](<#Postgres.GracefulShutdown>)
  - [func \(p \*Postgres\) MigrateDown\(ctx context.Context, migrationsDir string\) error](<#Postgres.MigrateDown>)
  - [func \(p \*Postgres\) MigrateUp\(ctx context.Context, migrationsDir string\) error](<#Postgres.MigrateUp>)
  - [func \(p \*Postgres\) MonitorConnection\(ctx context.Context\)](<#Postgres.MonitorConnection>)
  - [func \(p \*Postgres\) Query\(ctx context.Context\) \*QueryBuilder](<#Postgres.Query>)
  - [func \(p \*Postgres\) RetryConnection\(ctx context.Context, logger Logger\)](<#Postgres.RetryConnection>)
  - [func \(p \*Postgres\) Save\(ctx context.Context, value interface\{\}\) error](<#Postgres.Save>)
  - [func \(p \*Postgres\) Transaction\(ctx context.Context, fn func\(pg \*Postgres\) error\) error](<#Postgres.Transaction>)
  - [func \(p \*Postgres\) Update\(ctx context.Context, model interface\{\}, attrs interface\{\}\) error](<#Postgres.Update>)
  - [func \(p \*Postgres\) UpdateColumn\(ctx context.Context, model interface\{\}, columnName string, value interface\{\}\) error](<#Postgres.UpdateColumn>)
  - [func \(p \*Postgres\) UpdateColumns\(ctx context.Context, model interface\{\}, columnValues map\[string\]interface\{\}\) error](<#Postgres.UpdateColumns>)
  - [func \(p \*Postgres\) UpdateWhere\(ctx context.Context, model interface\{\}, attrs interface\{\}, condition string, args ...interface\{\}\) error](<#Postgres.UpdateWhere>)
- [type PostgresLifeCycleParams](<#PostgresLifeCycleParams>)
- [type PostgresParams](<#PostgresParams>)
- [type QueryBuilder](<#QueryBuilder>)
  - [func \(qb \*QueryBuilder\) Count\(count \*int64\) error](<#QueryBuilder.Count>)
  - [func \(qb \*QueryBuilder\) Delete\(value interface\{\}\) error](<#QueryBuilder.Delete>)
  - [func \(qb \*QueryBuilder\) Distinct\(args ...interface\{\}\) \*QueryBuilder](<#QueryBuilder.Distinct>)
  - [func \(qb \*QueryBuilder\) Done\(\)](<#QueryBuilder.Done>)
  - [func \(qb \*QueryBuilder\) Find\(dest interface\{\}\) error](<#QueryBuilder.Find>)
  - [func \(qb \*QueryBuilder\) First\(dest interface\{\}\) error](<#QueryBuilder.First>)
  - [func \(qb \*QueryBuilder\) Group\(query string\) \*QueryBuilder](<#QueryBuilder.Group>)
  - [func \(qb \*QueryBuilder\) Having\(query interface\{\}, args ...interface\{\}\) \*QueryBuilder](<#QueryBuilder.Having>)
  - [func \(qb \*QueryBuilder\) Joins\(query string, args ...interface\{\}\) \*QueryBuilder](<#QueryBuilder.Joins>)
  - [func \(qb \*QueryBuilder\) Last\(dest interface\{\}\) error](<#QueryBuilder.Last>)
  - [func \(qb \*QueryBuilder\) LeftJoin\(query string, args ...interface\{\}\) \*QueryBuilder](<#QueryBuilder.LeftJoin>)
  - [func \(qb \*QueryBuilder\) Limit\(limit int\) \*QueryBuilder](<#QueryBuilder.Limit>)
  - [func \(qb \*QueryBuilder\) MapRows\(destSlice interface\{\}, mapFn func\(\*gorm.DB\) error\) error](<#QueryBuilder.MapRows>)
  - [func \(qb \*QueryBuilder\) Model\(value interface\{\}\) \*QueryBuilder](<#QueryBuilder.Model>)
  - [func \(qb \*QueryBuilder\) Not\(query interface\{\}, args ...interface\{\}\) \*QueryBuilder](<#QueryBuilder.Not>)
  - [func \(qb \*QueryBuilder\) Offset\(offset int\) \*QueryBuilder](<#QueryBuilder.Offset>)
  - [func \(qb \*QueryBuilder\) Or\(query interface\{\}, args ...interface\{\}\) \*QueryBuilder](<#QueryBuilder.Or>)
  - [func \(qb \*QueryBuilder\) Order\(value interface\{\}\) \*QueryBuilder](<#QueryBuilder.Order>)
  - [func \(qb \*QueryBuilder\) Pluck\(column string, dest interface\{\}\) error](<#QueryBuilder.Pluck>)
  - [func \(qb \*QueryBuilder\) Preload\(query string, args ...interface\{\}\) \*QueryBuilder](<#QueryBuilder.Preload>)
  - [func \(qb \*QueryBuilder\) QueryRow\(\) RowScanner](<#QueryBuilder.QueryRow>)
  - [func \(qb \*QueryBuilder\) QueryRows\(\) \(RowsScanner, error\)](<#QueryBuilder.QueryRows>)
  - [func \(qb \*QueryBuilder\) Raw\(sql string, values ...interface\{\}\) \*QueryBuilder](<#QueryBuilder.Raw>)
  - [func \(qb \*QueryBuilder\) RightJoin\(query string, args ...interface\{\}\) \*QueryBuilder](<#QueryBuilder.RightJoin>)
  - [func \(qb \*QueryBuilder\) Scan\(dest interface\{\}\) error](<#QueryBuilder.Scan>)
  - [func \(qb \*QueryBuilder\) ScanRow\(dest interface\{\}\) error](<#QueryBuilder.ScanRow>)
  - [func \(qb \*QueryBuilder\) Select\(query interface\{\}, args ...interface\{\}\) \*QueryBuilder](<#QueryBuilder.Select>)
  - [func \(qb \*QueryBuilder\) Updates\(values interface\{\}\) error](<#QueryBuilder.Updates>)
  - [func \(qb \*QueryBuilder\) Where\(query interface\{\}, args ...interface\{\}\) \*QueryBuilder](<#QueryBuilder.Where>)
- [type RowScanner](<#RowScanner>)
- [type RowsScanner](<#RowsScanner>)


## Variables

<a name="ErrRecordNotFound"></a>Common database error types that can be used by consumers of this package. These provide a standardized set of errors that abstract away the underlying database\-specific error details.

```go
var (
    // ErrRecordNotFound is returned when a query doesn't find any matching records
    ErrRecordNotFound = errors.New("record not found")

    // ErrDuplicateKey is returned when an insert or update violates a unique constraint
    ErrDuplicateKey = errors.New("duplicate key violation")

    // ErrForeignKey is returned when an operation violates a foreign key constraint
    ErrForeignKey = errors.New("foreign key violation")

    // ErrInvalidData is returned when the data being saved doesn't meet validation rules
    ErrInvalidData = errors.New("invalid data")
)
```

<a name="FXModule"></a>FXModule is an fx module that provides the Postgres database component. It registers the Postgres constructor for dependency injection and sets up lifecycle hooks to properly initialize and shut down the database connection.

```go
var FXModule = fx.Module("postgres",
    fx.Provide(
        NewPostgresClientWithDI,
    ),
    fx.Invoke(RegisterPostgresLifecycle),
)
```

<a name="RegisterPostgresLifecycle"></a>
## func [RegisterPostgresLifecycle](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/fx_module.go#L88>)

```go
func RegisterPostgresLifecycle(params PostgresLifeCycleParams)
```

RegisterPostgresLifecycle registers lifecycle hooks for the Postgres database component. It sets up: 1. Connection monitoring on the application starts 2. Automatic reconnection mechanism on application start 3. Graceful shutdown of database connections on application stop

The function uses a WaitGroup to ensure that all goroutines complete before the application terminates.

<a name="TranslateError"></a>
## func [TranslateError](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/errors.go#L31>)

```go
func TranslateError(err error) error
```

TranslateError converts GORM/database\-specific errors into standardized application errors. This function provides abstraction from the underlying database implementation details, allowing application code to handle errors in a database\-agnostic way.

It maps common database errors to the standardized error types defined above. If an error doesn't match any known type, it's returned unchanged.

<a name="Config"></a>
## type [Config](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/configs.go#L7-L13>)

Config represents the complete configuration for a PostgresSQL database connection. It encapsulates both the basic connection parameters and detailed connection pool settings.

```go
type Config struct {
    // Connection contains the essential parameters needed to establish a database connection
    Connection Connection

    // ConnectionDetails contains configuration for the connection pool behavior
    ConnectionDetails ConnectionDetails
}
```

<a name="Connection"></a>
## type [Connection](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/configs.go#L17-L36>)

Connection holds the basic parameters required to connect to a PostgresSQL database. These parameters are used to construct the database connection string.

```go
type Connection struct {
    // Host specifies the database server hostname or IP address
    Host string

    // Port specifies the TCP port on which the database server is listening to
    Port string

    // User specifies the database username for authentication
    User string

    // Password specifies the database user password for authentication
    Password string

    // DbName specifies the name of the database to connect to
    DbName string

    // SSLMode specifies the SSL mode for the connection (e.g., "disable", "require", "verify-ca", "verify-full")
    // For production environments, it's recommended to use at least "require"
    SSLMode string
}
```

<a name="ConnectionDetails"></a>
## type [ConnectionDetails](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/configs.go#L41-L57>)

ConnectionDetails holds configuration settings for the database connection pool. These settings help optimize performance and resource usage by controlling how database connections are created, reused, and expired.

```go
type ConnectionDetails struct {
    // MaxOpenConns controls the maximum number of open connections to the database.
    // Setting this appropriately helps prevent overwhelming the database with too many connections.
    // Default is 0 (unlimited).
    MaxOpenConns int

    // MaxIdleConns controls the maximum number of connections in the idle connection pool.
    // A higher value can improve performance under a concurrent load but consumes more resources.
    // Default is 2.
    MaxIdleConns int

    // ConnMaxLifetime is the maximum amount of time a connection may be reused.
    // Expired connections are closed and removed from the pool during connection acquisition.
    // This helps ensure database-enforced timeouts are respected.
    // Default is 0 (unlimited).
    ConnMaxLifetime time.Duration
}
```

<a name="Logger"></a>
## type [Logger](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/setup.go#L17-L23>)



```go
type Logger interface {
    Info(msg string, err error, fields ...map[string]interface{})
    Debug(msg string, err error, fields ...map[string]interface{})
    Warn(msg string, err error, fields ...map[string]interface{})
    Error(msg string, err error, fields ...map[string]interface{})
    Fatal(msg string, err error, fields ...map[string]interface{})
}
```

<a name="Migration"></a>
## type [Migration](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/migrations.go#L42-L58>)

Migration represents a single database migration with all its metadata and content. Each migration contains the SQL to execute and information about its purpose and identity.

```go
type Migration struct {
    // ID is a unique identifier for the migration, typically a timestamp (YYYYMMDDHHMMSS)
    // that also helps establish the execution order.
    ID  string

    // Name is a descriptive label for the migration, typically describing what it does.
    Name string

    // Type categorizes the migration as either schema or data.
    Type MigrationType

    // Direction indicates whether this is an up (apply) or down (rollback) migration.
    Direction MigrationDirection

    // SQL contains the actual SQL statements to execute for this migration.
    SQL string
}
```

<a name="MigrationDirection"></a>
## type [MigrationDirection](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/migrations.go#L30>)

MigrationDirection specifies the direction of the migration, indicating whether it's applying a change or reverting one.

```go
type MigrationDirection string
```

<a name="UpMigration"></a>

```go
const (
    // UpMigration indicates a forward migration that applies a change.
    UpMigration MigrationDirection = "up"

    // DownMigration indicates a rollback migration that reverts a change.
    DownMigration MigrationDirection = "down"
)
```

<a name="MigrationHistoryRecord"></a>
## type [MigrationHistoryRecord](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/migrations.go#L63-L87>)

MigrationHistoryRecord represents a record in the migration history table. It tracks when and how each migration was applied, enabling the system to determine which migrations have been run and providing an audit trail.

```go
type MigrationHistoryRecord struct {
    // ID matches the migration ID that was applied.
    ID  string

    // Name is the descriptive name of the migration.
    Name string

    // Type indicates whether this was a schema or data migration.
    Type string

    // ExecutedAt records when the migration was applied.
    ExecutedAt time.Time

    // ExecutedBy tracks who or what system applied the migration.
    ExecutedBy string

    // Duration measures how long the migration took to execute in milliseconds.
    Duration int64

    // Status indicates whether the migration completed successfully or failed.
    Status string

    // ErrorMessage contains details if the migration failed.
    ErrorMessage string `gorm:"type:text"`
}
```

<a name="MigrationType"></a>
## type [MigrationType](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/migrations.go#L16>)

MigrationType defines the type of migration, categorizing the purpose of the change. This helps track and organize migrations based on their impact on the database.

```go
type MigrationType string
```

<a name="SchemaType"></a>

```go
const (
    // SchemaType represents schema changes (tables, columns, indexes, etc.)
    // These migrations modify the structure of the database.
    SchemaType MigrationType = "schema"

    // DataType represents data manipulations (inserts, updates, etc.)
    // These migrations modify the content within the database.
    DataType MigrationType = "data"
)
```

<a name="MockLogger"></a>
## type [MockLogger](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/mock_logger.go#L19-L23>)

MockLogger is a mock of Logger interface.

```go
type MockLogger struct {
    // contains filtered or unexported fields
}
```

<a name="NewMockLogger"></a>
### func [NewMockLogger](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/mock_logger.go#L31>)

```go
func NewMockLogger(ctrl *gomock.Controller) *MockLogger
```

NewMockLogger creates a new mock instance.

<a name="MockLogger.Debug"></a>
### func \(\*MockLogger\) [Debug](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/mock_logger.go#L43>)

```go
func (m *MockLogger) Debug(msg string, err error, fields ...map[string]any)
```

Debug mocks base method.

<a name="MockLogger.EXPECT"></a>
### func \(\*MockLogger\) [EXPECT](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/mock_logger.go#L38>)

```go
func (m *MockLogger) EXPECT() *MockLoggerMockRecorder
```

EXPECT returns an object that allows the caller to indicate expected use.

<a name="MockLogger.Error"></a>
### func \(\*MockLogger\) [Error](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/mock_logger.go#L60>)

```go
func (m *MockLogger) Error(msg string, err error, fields ...map[string]any)
```

Error mocks base method.

<a name="MockLogger.Fatal"></a>
### func \(\*MockLogger\) [Fatal](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/mock_logger.go#L77>)

```go
func (m *MockLogger) Fatal(msg string, err error, fields ...map[string]any)
```

Fatal mocks base method.

<a name="MockLogger.Info"></a>
### func \(\*MockLogger\) [Info](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/mock_logger.go#L94>)

```go
func (m *MockLogger) Info(msg string, err error, fields ...map[string]any)
```

Info mocks base method.

<a name="MockLogger.Warn"></a>
### func \(\*MockLogger\) [Warn](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/mock_logger.go#L111>)

```go
func (m *MockLogger) Warn(msg string, err error, fields ...map[string]any)
```

Warn mocks base method.

<a name="MockLoggerMockRecorder"></a>
## type [MockLoggerMockRecorder](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/mock_logger.go#L26-L28>)

MockLoggerMockRecorder is the mock recorder for MockLogger.

```go
type MockLoggerMockRecorder struct {
    // contains filtered or unexported fields
}
```

<a name="MockLoggerMockRecorder.Debug"></a>
### func \(\*MockLoggerMockRecorder\) [Debug](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/mock_logger.go#L53>)

```go
func (mr *MockLoggerMockRecorder) Debug(msg, err any, fields ...any) *gomock.Call
```

Debug indicates an expected call of Debug.

<a name="MockLoggerMockRecorder.Error"></a>
### func \(\*MockLoggerMockRecorder\) [Error](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/mock_logger.go#L70>)

```go
func (mr *MockLoggerMockRecorder) Error(msg, err any, fields ...any) *gomock.Call
```

Error indicates an expected call of Error.

<a name="MockLoggerMockRecorder.Fatal"></a>
### func \(\*MockLoggerMockRecorder\) [Fatal](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/mock_logger.go#L87>)

```go
func (mr *MockLoggerMockRecorder) Fatal(msg, err any, fields ...any) *gomock.Call
```

Fatal indicates an expected call of Fatal.

<a name="MockLoggerMockRecorder.Info"></a>
### func \(\*MockLoggerMockRecorder\) [Info](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/mock_logger.go#L104>)

```go
func (mr *MockLoggerMockRecorder) Info(msg, err any, fields ...any) *gomock.Call
```

Info indicates an expected call of Info.

<a name="MockLoggerMockRecorder.Warn"></a>
### func \(\*MockLoggerMockRecorder\) [Warn](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/mock_logger.go#L121>)

```go
func (mr *MockLoggerMockRecorder) Warn(msg, err any, fields ...any) *gomock.Call
```

Warn indicates an expected call of Warn.

<a name="Postgres"></a>
## type [Postgres](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/setup.go#L29-L39>)

Postgres is a thread\-safe wrapper around gorm.DB that provides connection monitoring, automatic reconnection, and standardized database operations. It guards all database operations with a mutex to ensure thread safety and includes mechanisms for graceful shutdown and connection health monitoring.

```go
type Postgres struct {
    Client *gorm.DB
    // contains filtered or unexported fields
}
```

<a name="NewPostgres"></a>
### func [NewPostgres](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/setup.go#L45>)

```go
func NewPostgres(cfg Config, logger Logger) *Postgres
```

NewPostgres creates a new Postgres instance with the provided configuration and Logger. It establishes the initial database connection and sets up the internal state for connection monitoring and recovery. If the initial connection fails, it logs a fatal error and terminates.

<a name="NewPostgresClientWithDI"></a>
### func [NewPostgresClientWithDI](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/fx_module.go#L61>)

```go
func NewPostgresClientWithDI(params PostgresParams) *Postgres
```

NewPostgresClientWithDI creates a new Postgres Client using dependency injection. This function is designed to be used with Uber's fx dependency injection framework where the Config and Logger dependencies are automatically provided via the PostgresParams struct.

Parameters:

- params: A PostgresParams struct containing the Config and Logger instances required to initialize the Postgres Client. This struct embeds fx.In to enable automatic injection of these dependencies.

Returns:

- \*Postgres: A fully initialized Postgres Client ready for use.

Example usage with fx:

```
app := fx.New(
    postgres.FXModule,
    fx.Provide(
        func() postgres.Config {
            return loadPostgresConfig() // Your config loading function
        },
        func() postgres.Logger {
            return initLogger() // Your logger initialization
        },
    ),
)
```

This function delegates to the standard NewPostgres function, maintaining the same initialization logic while enabling seamless integration with dependency injection.

<a name="Postgres.AutoMigrate"></a>
### func \(\*Postgres\) [AutoMigrate](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/migrations.go#L99>)

```go
func (p *Postgres) AutoMigrate(models ...interface{}) error
```

AutoMigrate is a wrapper around GORM's AutoMigrate with additional features. It tracks migrations in the migration history table and provides better error handling.

Parameters:

- models: The GORM models to auto\-migrate

Returns an error if any part of the migration process fails.

This method is useful during development or for simple applications, but for production systems, explicit migrations are recommended.

<a name="Postgres.Count"></a>
### func \(\*Postgres\) [Count](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/basic_ops.go#L222>)

```go
func (p *Postgres) Count(ctx context.Context, model interface{}, count *int64, conditions ...interface{}) error
```

Count determines the number of records that match the given conditions. It populates the count parameter with the result.

Parameters:

- ctx: Context for the database operation
- model: The model type to count
- count: Pointer to an int64 where the count will be stored
- conditions: Query conditions to filter the records to count

Returns an error if the query fails or nil on success.

Example:

```
var count int64
err := db.Count(ctx, &User{}, &count, "age > ?", 18)
```

<a name="Postgres.Create"></a>
### func \(\*Postgres\) [Create](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/basic_ops.go#L63>)

```go
func (p *Postgres) Create(ctx context.Context, value interface{}) error
```

Create inserts a new record into the database. It processes the value parameter according to GORM conventions, performing hooks and validations defined on the model.

Parameters:

- ctx: Context for the database operation
- value: The struct or slice of structs to be created

Returns an error if the creation fails or nil on success.

Example:

```
user := User{Name: "John", Email: "john@example.com"}
err := db.Create(ctx, &user)
```

<a name="Postgres.CreateMigration"></a>
### func \(\*Postgres\) [CreateMigration](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/migrations.go#L451>)

```go
func (p *Postgres) CreateMigration(migrationsDir, name string, migrationType MigrationType) (string, error)
```

CreateMigration generates a new migration file. It creates both up and down migration files with appropriate names and timestamps.

Parameters:

- migrationsDir: Directory where migration files should be created
- name: Descriptive name for the migration
- migrationType: Whether this is a schema or data migration

Returns the base filename of the created migration or an error if creation fails.

Example:

```
filename, err := db.CreateMigration("./migrations", "create_users_table", postgres.SchemaType)
if err == nil {
    fmt.Printf("Created migration: %s\n", filename)
}
```

<a name="Postgres.DB"></a>
### func \(\*Postgres\) [DB](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/utils.go#L14>)

```go
func (p *Postgres) DB() *gorm.DB
```

DB returns the underlying GORM DB Client instance. This method provides direct access to the database connection while maintaining thread safety through a read lock.

Use this method when you need to perform operations not covered by the wrapper methods or when you need to access specific GORM functionality. Note that direct usage bypasses some of the safety mechanisms, so use it with care.

<a name="Postgres.Delete"></a>
### func \(\*Postgres\) [Delete](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/basic_ops.go#L178>)

```go
func (p *Postgres) Delete(ctx context.Context, value interface{}, conditions ...interface{}) error
```

Delete removes records that match the given value and conditions from the database. It respects soft delete if implemented on the model.

Parameters:

- ctx: Context for the database operation
- value: The model to delete or a slice for batch delete
- conditions: Additional conditions to filter records to delete

Return an error if the deletion fails or nil on success.

Example:

```
// Delete user with ID=1
err := db.Delete(ctx, &User{}, "id = ?", 1)

// Or with a model instance
user := User{ID: 1}
err := db.Delete(ctx, &user)
```

<a name="Postgres.Exec"></a>
### func \(\*Postgres\) [Exec](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/basic_ops.go#L200>)

```go
func (p *Postgres) Exec(ctx context.Context, sql string, values ...interface{}) error
```

Exec executes raw SQL directly against the database. This is useful for operations not easily expressed through GORM's API or for performance\-critical code.

Parameters:

- ctx: Context for the database operation
- SQL: The SQL statement to execute
- values: Parameters for the SQL statement

Returns an error if the execution fails or nil on success.

Example:

```
err := db.Exec(ctx, "UPDATE users SET status = ? WHERE last_login < ?",
               "inactive", time.Now().AddDate(0, -6, 0))
```

<a name="Postgres.Find"></a>
### func \(\*Postgres\) [Find](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/basic_ops.go#L21>)

```go
func (p *Postgres) Find(ctx context.Context, dest interface{}, conditions ...interface{}) error
```

Find retrieves records from the database that match the given conditions. It populates the dest parameter with the query results.

Parameters:

- ctx: Context for the database operation
- dest: Pointer to a slice where the results will be stored
- conditions: Optional query conditions \(follows GORM conventions\)

Return an error if the query fails or nil on success.

Example:

```
var users []User
err := db.Find(ctx, &users, "name LIKE ?", "%john%")
```

<a name="Postgres.First"></a>
### func \(\*Postgres\) [First](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/basic_ops.go#L42>)

```go
func (p *Postgres) First(ctx context.Context, dest interface{}, conditions ...interface{}) error
```

First retrieves the first record that matches the given conditions. It populates the dest parameter with the result or returns an error if no matching record exists.

Parameters:

- ctx: Context for the database operation
- dest: Pointer to a struct where the result will be stored
- conditions: Optional query conditions \(follows GORM conventions\)

Return ErrRecordNotFound if no matching record exists, or another error if the query fails.

Example:

```
var user User
err := db.First(ctx, &user, "email = ?", "user@example.com")
```

<a name="Postgres.GetMigrationStatus"></a>
### func \(\*Postgres\) [GetMigrationStatus](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/migrations.go#L385>)

```go
func (p *Postgres) GetMigrationStatus(ctx context.Context, migrationsDir string) ([]map[string]interface{}, error)
```

GetMigrationStatus returns the status of all migrations. It compares available migrations with those that have been applied to build a comprehensive status report.

Parameters:

- ctx: Context for database operations
- migrationsDir: Directory containing the migration SQL files

Returns a slice of maps with status information for each migration, or an error if the status cannot be determined.

Example:

```
status, err := db.GetMigrationStatus(ctx, "./migrations")
if err == nil {
    for _, m := range status {
        fmt.Printf("Migration %s: %v\n", m["id"], m["applied"])
    }
}
```

<a name="Postgres.GracefulShutdown"></a>
### func \(\*Postgres\) [GracefulShutdown](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/fx_module.go#L131>)

```go
func (p *Postgres) GracefulShutdown() error
```



<a name="Postgres.MigrateDown"></a>
### func \(\*Postgres\) [MigrateDown](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/migrations.go#L249>)

```go
func (p *Postgres) MigrateDown(ctx context.Context, migrationsDir string) error
```

MigrateDown rolls back the last applied migration. It finds the most recently applied migration and executes its corresponding down migration to revert the changes.

Parameters:

- ctx: Context for database operations
- migrationsDir: Directory containing the migration SQL files

Returns an error if the rollback fails or if the down migration can't be found.

Example:

```
err := db.MigrateDown(ctx, "./migrations")
```

<a name="Postgres.MigrateUp"></a>
### func \(\*Postgres\) [MigrateUp](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/migrations.go#L151>)

```go
func (p *Postgres) MigrateUp(ctx context.Context, migrationsDir string) error
```

MigrateUp applies all pending migrations from the specified directory. It identifies which migrations haven't been applied yet, sorts them by ID, and applies them in order within transactions.

Parameters:

- ctx: Context for database operations
- migrationsDir: Directory containing the migration SQL files

Returns an error if any migration fails or if there are issues accessing the migrations.

Example:

```
err := db.MigrateUp(ctx, "./migrations")
```

<a name="Postgres.MonitorConnection"></a>
### func \(\*Postgres\) [MonitorConnection](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/setup.go#L149>)

```go
func (p *Postgres) MonitorConnection(ctx context.Context)
```

MonitorConnection periodically checks the health of the database connection and triggers reconnection attempts when necessary. It runs as a goroutine that performs health checks at regular intervals \(10 seconds\) and signals the RetryConnection goroutine when a failure is detected.

The function respects context cancellation and shutdown signals, ensuring proper resource cleanup and graceful termination when requested.

<a name="Postgres.Query"></a>
### func \(\*Postgres\) [Query](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/query_builder.go#L26>)

```go
func (p *Postgres) Query(ctx context.Context) *QueryBuilder
```

Query provides a flexible way to build complex queries. It returns a QueryBuilder which can be used to chain query methods in a fluent interface. The method acquires a read lock on the database connection that will be automatically released when a terminal method is called or Done\(\) is invoked.

Parameters:

- ctx: Context for the database operation

Returns a QueryBuilder instance that can be used to construct the query.

Example:

```
users := []User{}
err := db.Query(ctx).
    Where("age > ?", 18).
    Order("created_at DESC").
    Limit(10).
    Find(&users)
```

<a name="Postgres.RetryConnection"></a>
### func \(\*Postgres\) [RetryConnection](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/setup.go#L107>)

```go
func (p *Postgres) RetryConnection(ctx context.Context, logger Logger)
```

RetryConnection continuously attempts to reconnect to the PostgresSQL database when notified of a connection failure. It operates as a goroutine that waits for signals on retryChanSignal before attempting reconnection. The function respects context cancellation and shutdown signals, ensuring graceful termination when requested.

It implements two nested loops: \- The outer loop waits for retry signals \- The inner loop attempts reconnection until successful

<a name="Postgres.Save"></a>
### func \(\*Postgres\) [Save](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/basic_ops.go#L84>)

```go
func (p *Postgres) Save(ctx context.Context, value interface{}) error
```

Save updates the database record if the primary key exists, otherwise it creates a new record. It performs a full update of all fields, not just changed fields.

Parameters:

- ctx: Context for the database operation
- value: The struct to be saved

Returns an error if the operation fails or nil on success.

Example:

```
user.Name = "Updated Name"
err := db.Save(ctx, &user)
```

<a name="Postgres.Transaction"></a>
### func \(\*Postgres\) [Transaction](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/transactions.go#L39>)

```go
func (p *Postgres) Transaction(ctx context.Context, fn func(pg *Postgres) error) error
```

Transaction executes the given function within a database transaction. It creates a transaction\-specific Postgres instance and passes it to the provided function. If the function returns an error, the transaction is rolled back; otherwise, it's committed.

This method provides a clean way to execute multiple database operations as a single atomic unit, with automatic handling of commit/rollback based on the execution result.

Example usage:

```
err := pg.Transaction(ctx, func(txPg *Postgres) error {
	if err := txPg.Create(ctx, user); err != nil {
		return err
	}
	return txPg.Create(ctx, userProfile)
})
```

<a name="Postgres.Update"></a>
### func \(\*Postgres\) [Update](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/basic_ops.go#L106>)

```go
func (p *Postgres) Update(ctx context.Context, model interface{}, attrs interface{}) error
```

Update updates records that match the given model's non\-zero fields. It only updates the fields provided in attrs and only affects records that match the model's primary key or query conditions.

Parameters:

- ctx: Context for the database operation
- model: The model or query conditions to find records to update
- attrs: Map, struct, or name/value pairs for the fields to update

Returns an error if the update fails or nil on success.

Example:

```
// Update user with ID=1
err := db.Update(ctx, &User{ID: 1}, map[string]interface{}{"name": "New Name", "age": 30})
```

<a name="Postgres.UpdateColumn"></a>
### func \(\*Postgres\) [UpdateColumn](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/basic_ops.go#L129>)

```go
func (p *Postgres) UpdateColumn(ctx context.Context, model interface{}, columnName string, value interface{}) error
```

UpdateColumn updates a single column's value for records that match the given model. Unlike Update, it doesn't run hooks and can be used to update fields that are zero values \(like setting a string to empty or a number to zero\).

Parameters:

- ctx: Context for the database operation
- model: The model or query conditions to find records to update
- columnName: Name of the column to update
- value: New value for the column

Returns an error if the update fails or nil on success.

Example:

```
// Set status to "inactive" for user with ID=1
err := db.UpdateColumn(ctx, &User{ID: 1}, "status", "inactive")
```

<a name="Postgres.UpdateColumns"></a>
### func \(\*Postgres\) [UpdateColumns](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/basic_ops.go#L153>)

```go
func (p *Postgres) UpdateColumns(ctx context.Context, model interface{}, columnValues map[string]interface{}) error
```

UpdateColumns updates multiple columns with name/value pairs for records that match the given model. Like UpdateColumn, it doesn't run hooks and can update zero\-value fields.

Parameters:

- ctx: Context for the database operation
- model: The model or query conditions to find records to update
- columnValues: Map of column names to their new values

Returns an error if the update fails or nil on success.

Example:

```
// Update multiple fields for user with ID=1
err := db.UpdateColumns(ctx, &User{ID: 1}, map[string]interface{}{
    "status": "inactive",
    "last_login": time.Now(),
})
```

<a name="Postgres.UpdateWhere"></a>
### func \(\*Postgres\) [UpdateWhere](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/basic_ops.go#L248>)

```go
func (p *Postgres) UpdateWhere(ctx context.Context, model interface{}, attrs interface{}, condition string, args ...interface{}) error
```

UpdateWhere updates records that match the specified WHERE condition. This method provides more flexibility than Update for complex conditions.

Parameters:

- ctx: Context for the database operation
- model: The model type to update
- attrs: Fields to update \(map, struct, or name/value pairs\)
- condition: WHERE condition as a string
- args: Arguments for the WHERE condition

Returns an error if the update fails or nil on success.

Example:

```
// Update all users who haven't logged in for 6 months
err := db.UpdateWhere(ctx, &User{},
                      map[string]interface{}{"status": "inactive"},
                      "last_login < ?",
                      time.Now().AddDate(0, -6, 0))
```

<a name="PostgresLifeCycleParams"></a>
## type [PostgresLifeCycleParams](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/fx_module.go#L72-L78>)

PostgresLifeCycleParams groups the dependencies needed for Postgres lifecycle management. This struct combines all the components required to properly manage the lifecycle of a Postgres Client within an fx application, including startup, monitoring, and graceful shutdown.

The embedded fx.In marker enables automatic injection of the struct fields from the dependency container when this struct is used as a parameter in lifecycle registration functions.

```go
type PostgresLifeCycleParams struct {
    fx.In

    Lifecycle fx.Lifecycle
    Postgres  *Postgres
    Logger    Logger
}
```

<a name="PostgresParams"></a>
## type [PostgresParams](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/fx_module.go#L26-L31>)

PostgresParams groups the dependencies needed to create a Postgres Client via dependency injection. This struct is designed to work with Uber's fx dependency injection framework and provides the necessary parameters for initializing a Postgres database connection.

The embedded fx.In marker enables automatic injection of the struct fields from the dependency container when this struct is used as a parameter in provider functions.

```go
type PostgresParams struct {
    fx.In

    Config Config
    Logger Logger
}
```

<a name="QueryBuilder"></a>
## type [QueryBuilder](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/query_builder.go#L37-L43>)

QueryBuilder provides a fluent interface for building complex database queries. It wraps GORM's query building capabilities with thread\-safety and automatic resource cleanup. The builder maintains a chain of query modifiers that are applied when a terminal method is called.

```go
type QueryBuilder struct {
    // contains filtered or unexported fields
}
```

<a name="QueryBuilder.Count"></a>
### func \(\*QueryBuilder\) [Count](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/query_builder.go#L381>)

```go
func (qb *QueryBuilder) Count(count *int64) error
```

Count counts records that match the query conditions. This is a terminal method that executes the query and releases the mutex lock.

Parameters:

- count: Pointer to an int64 where the count will be stored

Returns an error if the query fails or nil on success.

Example:

```
var count int64
err := qb.Where("active = ?", true).Count(&count)
```

<a name="QueryBuilder.Delete"></a>
### func \(\*QueryBuilder\) [Delete](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/query_builder.go#L413>)

```go
func (qb *QueryBuilder) Delete(value interface{}) error
```

Delete deletes records that match the query conditions. This is a terminal method that executes the query and releases the mutex lock.

Parameters:

- value: Model value or pointer to specify what to delete

Returns an error if the deletion fails or nil on success.

Example:

```
err := qb.Where("created_at < ?", time.Now().AddDate(-1, 0, 0)).Delete(&User{})
```

<a name="QueryBuilder.Distinct"></a>
### func \(\*QueryBuilder\) [Distinct](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/query_builder.go#L448>)

```go
func (qb *QueryBuilder) Distinct(args ...interface{}) *QueryBuilder
```

Distinct specifies that the query should return distinct results. It eliminates duplicate rows from the result set.

Parameters:

- args: Optional columns to apply DISTINCT to

Returns the QueryBuilder for method chaining.

Example:

```
qb.Distinct("department").Find(&departments)
qb.Distinct().Where("age > ?", 18).Find(&users) // SELECT DISTINCT * FROM users WHERE age > 18
```

<a name="QueryBuilder.Done"></a>
### func \(\*QueryBuilder\) [Done](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/query_builder.go#L465>)

```go
func (qb *QueryBuilder) Done()
```

Done releases the mutex lock without executing the query. This method should be called when you want to cancel a query building chain without executing any terminal operation.

Example:

```
qb := db.Query(ctx)
if someCondition {
    err := qb.Where(...).Find(&results)
} else {
    qb.Done() // Release the lock without executing
}
```

<a name="QueryBuilder.Find"></a>
### func \(\*QueryBuilder\) [Find](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/query_builder.go#L330>)

```go
func (qb *QueryBuilder) Find(dest interface{}) error
```

Find finds records that match the query conditions. This is a terminal method that executes the query and releases the mutex lock.

Parameters:

- dest: Pointer to a slice where results will be stored

Returns an error if the query fails or nil on success.

Example:

```
var users []User
err := qb.Where("active = ?", true).Find(&users)
```

<a name="QueryBuilder.First"></a>
### func \(\*QueryBuilder\) [First](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/query_builder.go#L347>)

```go
func (qb *QueryBuilder) First(dest interface{}) error
```

First finds the first record that matches the query conditions. This is a terminal method that executes the query and releases the mutex lock.

Parameters:

- dest: Pointer to a struct where the result will be stored

Returns an error if no record is found or the query fails, nil on success.

Example:

```
var user User
err := qb.Where("email = ?", "user@example.com").First(&user)
```

<a name="QueryBuilder.Group"></a>
### func \(\*QueryBuilder\) [Group](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/query_builder.go#L198>)

```go
func (qb *QueryBuilder) Group(query string) *QueryBuilder
```

Group adds a GROUP BY clause to the query. It is used to group rows with the same values into summary rows.

Parameters:

- query: GROUP BY expression

Returns the QueryBuilder for method chaining.

Example:

```
qb.Group("status")
qb.Group("department, location")
```

<a name="QueryBuilder.Having"></a>
### func \(\*QueryBuilder\) [Having](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/query_builder.go#L215>)

```go
func (qb *QueryBuilder) Having(query interface{}, args ...interface{}) *QueryBuilder
```

Having added a HAVING clause to the query. It is used to filter groups created by the GROUP BY clause.

Parameters:

- query: HAVING condition with optional placeholders
- args: Arguments for any placeholders in the query

Returns the QueryBuilder for method chaining.

Example:

```
qb.Group("department").Having("COUNT(*) > ?", 3)
```

<a name="QueryBuilder.Joins"></a>
### func \(\*QueryBuilder\) [Joins](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/query_builder.go#L127>)

```go
func (qb *QueryBuilder) Joins(query string, args ...interface{}) *QueryBuilder
```

Joins add a JOIN clause to the query. It performs an INNER JOIN by default.

Parameters:

- query: JOIN condition string
- args: Arguments for any placeholders in the query

Returns the QueryBuilder for method chaining.

Example:

```
qb.Joins("JOIN orders ON orders.user_id = users.id")
```

<a name="QueryBuilder.Last"></a>
### func \(\*QueryBuilder\) [Last](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/query_builder.go#L364>)

```go
func (qb *QueryBuilder) Last(dest interface{}) error
```

Last finds the last record that matches the query conditions. This is a terminal method that executes the query and releases the mutex lock.

Parameters:

- dest: Pointer to a struct where the result will be stored

Returns an error if no record is found or the query fails, nil on success.

Example:

```
var user User
err := qb.Where("department = ?", "Engineering").Order("joined_at ASC").Last(&user)
```

<a name="QueryBuilder.LeftJoin"></a>
### func \(\*QueryBuilder\) [LeftJoin](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/query_builder.go#L144>)

```go
func (qb *QueryBuilder) LeftJoin(query string, args ...interface{}) *QueryBuilder
```

LeftJoin adds a LEFT JOIN clause to the query. It retrieves all records from the left table and matching records from the right table.

Parameters:

- query: JOIN condition string without the "LEFT JOIN" prefix
- args: Arguments for any placeholders in the query

Returns the QueryBuilder for method chaining.

Example:

```
qb.LeftJoin("orders ON orders.user_id = users.id")
```

<a name="QueryBuilder.Limit"></a>
### func \(\*QueryBuilder\) [Limit](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/query_builder.go#L247>)

```go
func (qb *QueryBuilder) Limit(limit int) *QueryBuilder
```

Limit sets the maximum number of records to return.

Parameters:

- limit: Maximum number of records

Returns the QueryBuilder for method chaining.

Example:

```
qb.Limit(10) // Return at most 10 records
```

<a name="QueryBuilder.MapRows"></a>
### func \(\*QueryBuilder\) [MapRows](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/row_scanner.go#L66>)

```go
func (qb *QueryBuilder) MapRows(destSlice interface{}, mapFn func(*gorm.DB) error) error
```

MapRows executes a query and maps all rows into a destination slice using the provided mapping function. This provides a higher\-level abstraction than working with raw rows, allowing for custom mapping logic while still handling the query execution and resource management automatically.

Parameters:

- destSlice: The slice to populate with mapped rows \(should be a pointer to a slice\)
- mapFn: A function that defines how to map rows from the database to your slice items

<a name="QueryBuilder.Model"></a>
### func \(\*QueryBuilder\) [Model](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/query_builder.go#L296>)

```go
func (qb *QueryBuilder) Model(value interface{}) *QueryBuilder
```

Model specifies the model to use for the query. This is useful when the model can't be inferred from other methods.

Parameters:

- value: Pointer to the model struct or its instance

Returns the QueryBuilder for method chaining.

Example:

```
qb.Model(&User{}).Where("active = ?", true).Count(&count)
```

<a name="QueryBuilder.Not"></a>
### func \(\*QueryBuilder\) [Not](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/query_builder.go#L110>)

```go
func (qb *QueryBuilder) Not(query interface{}, args ...interface{}) *QueryBuilder
```

Not adds a NOT condition to the query. It negates the specified condition.

Parameters:

- query: Condition string with optional placeholders or a map of conditions
- args: Arguments for any placeholders in the query

Returns the QueryBuilder for method chaining.

Example:

```
qb.Not("status = ?", "deleted")
```

<a name="QueryBuilder.Offset"></a>
### func \(\*QueryBuilder\) [Offset](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/query_builder.go#L263>)

```go
func (qb *QueryBuilder) Offset(offset int) *QueryBuilder
```

Offset sets the number of records to skip. It is typically used with Limit for pagination.

Parameters:

- offset: Number of records to skip

Returns the QueryBuilder for method chaining.

Example:

```
qb.Offset(20).Limit(10) // Skip 20 records and return the next 10
```

<a name="QueryBuilder.Or"></a>
### func \(\*QueryBuilder\) [Or](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/query_builder.go#L93>)

```go
func (qb *QueryBuilder) Or(query interface{}, args ...interface{}) *QueryBuilder
```

Or adds an OR condition to the query. It combines with previous conditions using OR logic.

Parameters:

- query: Condition string with optional placeholders or a map of conditions
- args: Arguments for any placeholders in the query

Returns the QueryBuilder for method chaining.

Example:

```
qb.Where("status = ?", "active").Or("status = ?", "pending")
```

<a name="QueryBuilder.Order"></a>
### func \(\*QueryBuilder\) [Order](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/query_builder.go#L232>)

```go
func (qb *QueryBuilder) Order(value interface{}) *QueryBuilder
```

Order adds an ORDER BY clause to the query. It is used to sort the result set.

Parameters:

- value: ORDER BY expression

Returns the QueryBuilder for method chaining.

Example:

```
qb.Order("created_at DESC")
qb.Order("age ASC, name DESC")
```

<a name="QueryBuilder.Pluck"></a>
### func \(\*QueryBuilder\) [Pluck](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/query_builder.go#L431>)

```go
func (qb *QueryBuilder) Pluck(column string, dest interface{}) error
```

Pluck queries a single column and scans the results into a slice. This is a terminal method that executes the query and releases the mutex lock.

Parameters:

- column: Name of the column to query
- dest: Pointer to a slice where results will be stored

Returns an error if the query fails or nil on success.

Example:

```
var emails []string
err := qb.Where("department = ?", "Engineering").Pluck("email", &emails)
```

<a name="QueryBuilder.Preload"></a>
### func \(\*QueryBuilder\) [Preload](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/query_builder.go#L181>)

```go
func (qb *QueryBuilder) Preload(query string, args ...interface{}) *QueryBuilder
```

Preload preloads associations for the query results. This is used to eagerly load related models to avoid N\+1 query problems.

Parameters:

- query: Name of the association to preload
- args: Optional conditions for the preloaded association

Return the QueryBuilder for method chaining.

Example:

```
qb.Preload("Orders")
qb.Preload("Orders", "state = ?", "paid")
```

<a name="QueryBuilder.QueryRow"></a>
### func \(\*QueryBuilder\) [QueryRow](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/row_scanner.go#L36>)

```go
func (qb *QueryBuilder) QueryRow() RowScanner
```

QueryRow executes a query expected to return a single row and returns a RowScanner for it. This method is optimized for queries that return exactly one row of data and provides a simplified interface for scanning the values from that row.

<a name="QueryBuilder.QueryRows"></a>
### func \(\*QueryBuilder\) [QueryRows](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/row_scanner.go#L44>)

```go
func (qb *QueryBuilder) QueryRows() (RowsScanner, error)
```

QueryRows executes a query that returns multiple rows and returns a RowsScanner for them. This method provides an iterator\-style interface for processing multiple rows returned by a query, allowing for efficient traversal of large result sets.

<a name="QueryBuilder.Raw"></a>
### func \(\*QueryBuilder\) [Raw](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/query_builder.go#L280>)

```go
func (qb *QueryBuilder) Raw(sql string, values ...interface{}) *QueryBuilder
```

Raw executes raw SQL as part of the query. It provides full SQL flexibility when needed.

Parameters:

- SQL: Raw SQL statement with optional placeholders
- values: Arguments for any placeholders in the SQL

Returns the QueryBuilder for method chaining.

Example:

```
qb.Raw("SELECT * FROM users WHERE created_at > ?", time.Now().AddDate(0, -1, 0))
```

<a name="QueryBuilder.RightJoin"></a>
### func \(\*QueryBuilder\) [RightJoin](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/query_builder.go#L162>)

```go
func (qb *QueryBuilder) RightJoin(query string, args ...interface{}) *QueryBuilder
```

RightJoin adds a RIGHT JOIN clause to the query. It retrieves all records from the right table and matching records from the left table.

Parameters:

- query: JOIN condition string without the "RIGHT JOIN" prefix
- args: Arguments for any placeholders in the query

Returns the QueryBuilder for method chaining.

Example:

```
qb.RightJoin("orders ON orders.user_id = users.id")
```

<a name="QueryBuilder.Scan"></a>
### func \(\*QueryBuilder\) [Scan](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/query_builder.go#L313>)

```go
func (qb *QueryBuilder) Scan(dest interface{}) error
```

Scan scans the result into the destination struct or slice. This is a terminal method that executes the query and releases the mutex lock.

Parameters:

- dest: Pointer to the struct or slice where results will be stored

Returns an error if the query fails or nil on success.

Example:

```
var result struct{ Count int }
err := qb.Raw("SELECT COUNT(*) as count FROM users").Scan(&result)
```

<a name="QueryBuilder.ScanRow"></a>
### func \(\*QueryBuilder\) [ScanRow](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/row_scanner.go#L53>)

```go
func (qb *QueryBuilder) ScanRow(dest interface{}) error
```

ScanRow is a convenience method to scan a single row directly into a struct. This is a higher\-level alternative to QueryRow that automatically maps column values to struct fields based on naming conventions or field tags. It's useful when you need to map a row to a predefined data structure.

<a name="QueryBuilder.Select"></a>
### func \(\*QueryBuilder\) [Select](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/query_builder.go#L58>)

```go
func (qb *QueryBuilder) Select(query interface{}, args ...interface{}) *QueryBuilder
```

Select specifies fields to be selected in the query. It corresponds to the SQL SELECT clause.

Parameters:

- query: Field selection string or raw SQL expression
- args: Arguments for any placeholders in the query

Returns the QueryBuilder for method chaining.

Example:

```
qb.Select("id, name, email")
qb.Select("COUNT(*) as user_count")
```

<a name="QueryBuilder.Updates"></a>
### func \(\*QueryBuilder\) [Updates](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/query_builder.go#L397>)

```go
func (qb *QueryBuilder) Updates(values interface{}) error
```

Updates updates records that match the query conditions. This is a terminal method that executes the query and releases the mutex lock.

Parameters:

- values: Map or struct with the fields to update

Returns an error if the update fails or nil on success.

Example:

```
err := qb.Where("expired = ?", true).Updates(map[string]interface{}{"active": false})
```

<a name="QueryBuilder.Where"></a>
### func \(\*QueryBuilder\) [Where](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/query_builder.go#L76>)

```go
func (qb *QueryBuilder) Where(query interface{}, args ...interface{}) *QueryBuilder
```

Where adds a WHERE condition to the query. Multiple Where calls are combined with AND logic.

Parameters:

- query: Condition string with optional placeholders or a map of conditions
- args: Arguments for any placeholders in the query

Returns the QueryBuilder for method chaining.

Example:

```
qb.Where("age > ?", 18)
qb.Where("status = ?", "active")
```

<a name="RowScanner"></a>
## type [RowScanner](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/row_scanner.go#L10-L14>)

RowScanner provides an interface for scanning a single row of data. It abstracts the process of parsing column values into Go variables, allowing for efficient handling of individual rows returned from a query.

```go
type RowScanner interface {
    // Scan copies the column values from the current row into the values pointed to by dest.
    // The number of values in dest must match the number of columns in the row.
    Scan(dest ...interface{}) error
}
```

<a name="RowsScanner"></a>
## type [RowsScanner](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/postgres/row_scanner.go#L19-L31>)

RowsScanner provides an interface for iterating through rows of data returned by a query. It extends RowScanner functionality with methods for navigation and error handling, allowing for efficient processing of result sets with multiple rows.

```go
type RowsScanner interface {
    // Next prepares the next row for reading. It returns false when there are no more rows.
    Next() bool

    // Scan copies column values from the current row into the provided destination variables.
    Scan(dest ...interface{}) error

    // Close closes the rows iterator, releasing any associated resources.
    Close() error

    // Err returns any error encountered during iteration.
    Err() error
}
```

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
