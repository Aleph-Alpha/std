<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# rabbit

```go
import "gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/pkg/rabbit"
```

Package rabbit provides functionality for interacting with RabbitMQ.

The rabbit package offers a simplified interface for working with RabbitMQ message queues, providing connection management, message publishing, and consuming capabilities with a focus on reliability and ease of use.

Core Features:

- Robust connection management with automatic reconnection
- Simple publishing interface with error handling
- Consumer interface with automatic acknowledgment handling
- Dead letter queue support
- Integration with the Logger package for structured logging

Basic Usage:

```
import (
	"gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/pkg/rabbit"
	"gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/pkg/logger"
	"context"
	"sync"
)

// Create a logger
log, _ := logger.NewLogger(logger.Config{Level: "info"})

// Create a new RabbitMQ client
, err := rabbit.New(rabbit.Config{
	Connection: rabbit.ConnectionConfig{
		URI: "amqp://guest:guest@localhost:5672/",
	},
	Channel: rabbit.ChannelConfig{
		ExchangeName: "events",
		ExchangeType: "topic",
		RoutingKey:   "user.created",
		QueueName:    "user-events",
		ContentType:  "application/json",
	},
}, log)
if err != nil {
	log.Fatal("Failed to connect to RabbitMQ", err, nil)
}
defer client.Close()

// Publish a message
ctx := context.Background()
message := []byte(`{"id": "123", "name": "John"}`)
err = client.Publish(ctx, message)
if err != nil {
	log.Error("Failed to publish message", err, nil)
}

// Consume messages
wg := &sync.WaitGroup{}
ctx, cancel := context.WithCancel(context.Background())
defer cancel()

msgChan := client.Consume(ctx, wg)
for msg := range msgChan {
	log.Info("Received message", nil, map[string]interface{}{
		"body": string(msg.Body()),
	})

	// Process the message

	// Acknowledge the message
	if err := msg.AckMsg(); err != nil {
		log.Error("Failed to acknowledge message", err, nil)
	}
}
```

Consuming from Dead Letter Queue:

```
dlqChan := client.ConsumeDLQ(ctx, wg)
for msg := range dlqChan {
	log.Info("Processing failed message", nil, map[string]interface{}{
		"body": string(msg.Body()),
	})

	// Process the failed message

	// Acknowledge after processing
	msg.AckMsg()
}
```

FX Module Integration:

This package provides a fx module for easy integration:

```
app := fx.New(
	logger.Module,
	rabbit.Module,
	// ... other modules
)
app.Run()
```

Configuration:

The rabbit client can be configured via environment variables or explicitly:

```
RABBIT_URI=amqp://guest:guest@localhost:5672/
RABBIT_EXCHANGE_NAME=events
RABBIT_EXCHANGE_TYPE=topic
RABBIT_ROUTING_KEY=user.created
RABBIT_QUEUE_NAME=user-events
```

Thread Safety:

All methods on the Rabbit type are safe for concurrent use by multiple goroutines, except for Close\(\) which should only be called once.

Package rabbit is a generated GoMock package.

## Index

- [Variables](<#variables>)
- [func RegisterRabbitLifecycle\(lc fx.Lifecycle, client \*Rabbit, logger Logger, cfg Config\)](<#RegisterRabbitLifecycle>)
- [type Channel](<#Channel>)
- [type Config](<#Config>)
- [type Connection](<#Connection>)
- [type ConsumerMessage](<#ConsumerMessage>)
  - [func \(rb \*ConsumerMessage\) AckMsg\(\) error](<#ConsumerMessage.AckMsg>)
  - [func \(rb \*ConsumerMessage\) Body\(\) \[\]byte](<#ConsumerMessage.Body>)
  - [func \(rb \*ConsumerMessage\) NackMsg\(requeue bool\) error](<#ConsumerMessage.NackMsg>)
- [type DeadLetter](<#DeadLetter>)
- [type Logger](<#Logger>)
- [type Message](<#Message>)
- [type MockLogger](<#MockLogger>)
  - [func NewMockLogger\(ctrl \*gomock.Controller\) \*MockLogger](<#NewMockLogger>)
  - [func \(m \*MockLogger\) Debug\(msg string, err error, fields ...map\[string\]any\)](<#MockLogger.Debug>)
  - [func \(m \*MockLogger\) EXPECT\(\) \*MockLoggerMockRecorder](<#MockLogger.EXPECT>)
  - [func \(m \*MockLogger\) Error\(msg string, err error, fields ...map\[string\]any\)](<#MockLogger.Error>)
  - [func \(m \*MockLogger\) Fatal\(msg string, err error, fields ...map\[string\]any\)](<#MockLogger.Fatal>)
  - [func \(m \*MockLogger\) Info\(msg string, err error, fields ...map\[string\]any\)](<#MockLogger.Info>)
  - [func \(m \*MockLogger\) Warn\(msg string, err error, fields ...map\[string\]any\)](<#MockLogger.Warn>)
- [type MockLoggerMockRecorder](<#MockLoggerMockRecorder>)
  - [func \(mr \*MockLoggerMockRecorder\) Debug\(msg, err any, fields ...any\) \*gomock.Call](<#MockLoggerMockRecorder.Debug>)
  - [func \(mr \*MockLoggerMockRecorder\) Error\(msg, err any, fields ...any\) \*gomock.Call](<#MockLoggerMockRecorder.Error>)
  - [func \(mr \*MockLoggerMockRecorder\) Fatal\(msg, err any, fields ...any\) \*gomock.Call](<#MockLoggerMockRecorder.Fatal>)
  - [func \(mr \*MockLoggerMockRecorder\) Info\(msg, err any, fields ...any\) \*gomock.Call](<#MockLoggerMockRecorder.Info>)
  - [func \(mr \*MockLoggerMockRecorder\) Warn\(msg, err any, fields ...any\) \*gomock.Call](<#MockLoggerMockRecorder.Warn>)
- [type Rabbit](<#Rabbit>)
  - [func NewClient\(cfg Config, logger Logger\) \*Rabbit](<#NewClient>)
  - [func \(rb \*Rabbit\) Consume\(ctx context.Context, wg \*sync.WaitGroup\) \<\-chan Message](<#Rabbit.Consume>)
  - [func \(rb \*Rabbit\) ConsumeDLQ\(ctx context.Context, wg \*sync.WaitGroup\) \<\-chan Message](<#Rabbit.ConsumeDLQ>)
  - [func \(rb \*Rabbit\) Publish\(ctx context.Context, msg \[\]byte\) error](<#Rabbit.Publish>)


## Variables

<a name="FXModule"></a>FXModule is an fx.Module that provides and configures the RabbitMQ client. This module registers the RabbitMQ client with the Fx dependency injection framework, making it available to other components in the application.

The module: 1. Provides the RabbitMQ client factory function 2. Invokes the lifecycle registration to manage the client's lifecycle

Usage:

```
app := fx.New(
    rabbit.FXModule,
    // other modules...
)
```

```go
var FXModule = fx.Module("rabbit",
    fx.Provide(
        NewClient,
    ),
    fx.Invoke(RegisterRabbitLifecycle),
)
```

<a name="RegisterRabbitLifecycle"></a>
## func [RegisterRabbitLifecycle](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/rabbit/fx_module.go#L48>)

```go
func RegisterRabbitLifecycle(lc fx.Lifecycle, client *Rabbit, logger Logger, cfg Config)
```

RegisterRabbitLifecycle registers the RabbitMQ client with the fx lifecycle system. This function sets up proper initialization and graceful shutdown of the RabbitMQ client, including starting the connection monitoring goroutine.

Parameters:

- lc: The fx lifecycle controller
- client: The RabbitMQ client instance
- logger: Logger for recording lifecycle events
- cfg: Configuration for the RabbitMQ client

The function:

1. On application start: Launches a background goroutine that monitors and maintains the RabbitMQ connection, automatically reconnecting if it fails.
2. On application stop: Triggers a graceful shutdown of the RabbitMQ client, closing channels and connections cleanly.

This ensures that the RabbitMQ client remains available throughout the application's lifetime and is properly cleaned up during shutdown.

<a name="Channel"></a>
## type [Channel](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/rabbit/configs.go#L60-L92>)

Channel contains configuration for AMQP channels, exchanges, queues, and bindings. These settings determine how messages are routed and processed.

```go
type Channel struct {
    // ExchangeName is the name of the exchange to publish to or consume from
    ExchangeName string

    // ExchangeType defines the routing behavior of the exchange
    // Common values: "direct", "fanout", "topic", "headers"
    ExchangeType string

    // RoutingKey is used for routing messages from exchanges to queues
    // The meaning depends on the exchange type:
    // - For direct exchanges: exact matching key
    // - For topic exchanges: routing pattern with wildcards
    // - For fanout exchanges: ignored
    RoutingKey string

    // QueueName is the name of the queue to declare or consume from
    QueueName string

    // DelayToReconnect is the time in milliseconds to wait between reconnection attempts
    DelayToReconnect int

    // PrefetchCount limits the number of unacknowledged messages that can be sent to a consumer
    // A value of 0 means no limit (not recommended for production)
    PrefetchCount int

    // IsConsumer determines whether this client will declare exchanges and queues
    // Set to true for consumers, false for publishers that use existing exchanges
    IsConsumer bool

    // ContentType specifies the MIME type of published messages
    // Common values: "application/json", "text/plain", "application/octet-stream"
    ContentType string
}
```

<a name="Config"></a>
## type [Config](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/rabbit/configs.go#L6-L16>)

Config defines the top\-level configuration structure for the RabbitMQ client. It contains all the necessary configuration sections for establishing connections, setting up channels, and configuring dead\-letter behavior.

```go
type Config struct {
    // Connection contains the settings needed to establish a connection to the RabbitMQ server
    Connection Connection

    // Channel contains configuration for exchanges, queues, and message routing
    Channel Channel

    // DeadLetter contains configuration for the dead-letter exchange and queue
    // used for handling failed messages
    DeadLetter DeadLetter
}
```

<a name="Connection"></a>
## type [Connection](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/rabbit/configs.go#L20-L56>)

Connection contains the configuration parameters needed to establish a connection to a RabbitMQ server, including authentication and TLS settings.

```go
type Connection struct {
    // Host is the RabbitMQ server hostname or IP address
    Host string

    // Port is the RabbitMQ server port (typically 5672 for non-SSL, 5671 for SSL)
    Port uint

    // User is the RabbitMQ username for authentication
    User string

    // Password is the RabbitMQ password for authentication
    Password string

    // IsSSLEnabled determines whether to use SSL/TLS for the connection
    // When true, connections will use the AMQPs protocol
    IsSSLEnabled bool

    // UseCert determines whether to use client certificate authentication
    // When true, client certificates will be sent for mutual TLS authentication
    UseCert bool

    // CACertPath is the file path to the CA certificate for verifying the server
    // Used when IsSSLEnabled is true
    CACertPath string

    // ClientCertPath is the file path to the client certificate
    // Used when both IsSSLEnabled and UseCert are true
    ClientCertPath string

    // ClientKeyPath is the file path to the client certificate's private key
    // Used when both IsSSLEnabled and UseCert are true
    ClientKeyPath string

    // ServerName is the server name to use for TLS verification
    // This should match a CN or SAN in the server's certificate
    ServerName string
}
```

<a name="ConsumerMessage"></a>
## type [ConsumerMessage](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/rabbit/utils.go#L30-L33>)

ConsumerMessage implements the Message interface and wraps an AMQP delivery. This struct provides access to the message content and acknowledgment methods.

```go
type ConsumerMessage struct {
    // contains filtered or unexported fields
}
```

<a name="ConsumerMessage.AckMsg"></a>
### func \(\*ConsumerMessage\) [AckMsg](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/rabbit/utils.go#L237>)

```go
func (rb *ConsumerMessage) AckMsg() error
```

AckMsg acknowledges the message, informing RabbitMQ that the message has been successfully processed and can be removed from the queue.

Returns an error if the acknowledgment fails.

<a name="ConsumerMessage.Body"></a>
### func \(\*ConsumerMessage\) [Body](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/rabbit/utils.go#L254>)

```go
func (rb *ConsumerMessage) Body() []byte
```

Body returns the message payload as a byte slice.

<a name="ConsumerMessage.NackMsg"></a>
### func \(\*ConsumerMessage\) [NackMsg](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/rabbit/utils.go#L249>)

```go
func (rb *ConsumerMessage) NackMsg(requeue bool) error
```

NackMsg rejects the message. If requeue is true, the message will be returned to the queue for redelivery; otherwise, it will be discarded or sent to a dead\-letter exchange if configured.

Parameters:

- requeue: Whether to requeue the message for another delivery attempt

Returns an error if the rejection fails.

<a name="DeadLetter"></a>
## type [DeadLetter](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/rabbit/configs.go#L97-L112>)

DeadLetter contains configuration for dead\-letter handling. Dead\-letter exchanges receive messages that are rejected, expire, or exceed queue limits. This provides a mechanism for handling failed message processing.

```go
type DeadLetter struct {
    // ExchangeName is the name of the dead-letter exchange
    ExchangeName string

    // QueueName is the name of the queue bound to the dead-letter exchange
    QueueName string

    // RoutingKey is the routing key used when dead-lettering messages
    // This can be different from the original routing key
    RoutingKey string

    // Ttl is the time-to-live for messages in seconds
    // Messages that remain in the queue longer than this TTL will be dead-lettered
    // A value of 0 means no TTL (messages never expire)
    Ttl int
}
```

<a name="Logger"></a>
## type [Logger](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/rabbit/setup.go#L18-L33>)

Logger defines the interface for logging operations in the rabbit package. This interface allows the package to use any logging implementation that conforms to these methods.

```go
type Logger interface {
    // Info logs informational messages, optionally with error and contextual fields
    Info(msg string, err error, fields ...map[string]interface{})

    // Debug logs debug-level messages, optionally with error and contextual fields
    Debug(msg string, err error, fields ...map[string]interface{})

    // Warn logs warning messages, optionally with error and contextual fields
    Warn(msg string, err error, fields ...map[string]interface{})

    // Error logs error messages with the associated error and optional contextual fields
    Error(msg string, err error, fields ...map[string]interface{})

    // Fatal logs critical errors that should terminate the application
    Fatal(msg string, err error, fields ...map[string]interface{})
}
```

<a name="Message"></a>
## type [Message](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/rabbit/utils.go#L14-L26>)

Message defines the interface for consumed messages from RabbitMQ. This interface abstracts the underlying AMQP message structure and provides methods for acknowledging or rejecting messages.

```go
type Message interface {
    // AckMsg acknowledges the message, informing RabbitMQ that the message
    // has been successfully processed and can be removed from the queue.
    AckMsg() error

    // NackMsg rejects the message. If requeue is true, the message will be
    // returned to the queue for redelivery; otherwise, it will be discarded
    // or sent to a dead-letter exchange if configured.
    NackMsg(requeue bool) error

    // Body returns the message payload as a byte slice.
    Body() []byte
}
```

<a name="MockLogger"></a>
## type [MockLogger](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/rabbit/mock_logger.go#L19-L23>)

MockLogger is a mock of Logger interface.

```go
type MockLogger struct {
    // contains filtered or unexported fields
}
```

<a name="NewMockLogger"></a>
### func [NewMockLogger](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/rabbit/mock_logger.go#L31>)

```go
func NewMockLogger(ctrl *gomock.Controller) *MockLogger
```

NewMockLogger creates a new mock instance.

<a name="MockLogger.Debug"></a>
### func \(\*MockLogger\) [Debug](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/rabbit/mock_logger.go#L43>)

```go
func (m *MockLogger) Debug(msg string, err error, fields ...map[string]any)
```

Debug mocks base method.

<a name="MockLogger.EXPECT"></a>
### func \(\*MockLogger\) [EXPECT](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/rabbit/mock_logger.go#L38>)

```go
func (m *MockLogger) EXPECT() *MockLoggerMockRecorder
```

EXPECT returns an object that allows the caller to indicate expected use.

<a name="MockLogger.Error"></a>
### func \(\*MockLogger\) [Error](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/rabbit/mock_logger.go#L60>)

```go
func (m *MockLogger) Error(msg string, err error, fields ...map[string]any)
```

Error mocks base method.

<a name="MockLogger.Fatal"></a>
### func \(\*MockLogger\) [Fatal](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/rabbit/mock_logger.go#L77>)

```go
func (m *MockLogger) Fatal(msg string, err error, fields ...map[string]any)
```

Fatal mocks base method.

<a name="MockLogger.Info"></a>
### func \(\*MockLogger\) [Info](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/rabbit/mock_logger.go#L94>)

```go
func (m *MockLogger) Info(msg string, err error, fields ...map[string]any)
```

Info mocks base method.

<a name="MockLogger.Warn"></a>
### func \(\*MockLogger\) [Warn](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/rabbit/mock_logger.go#L111>)

```go
func (m *MockLogger) Warn(msg string, err error, fields ...map[string]any)
```

Warn mocks base method.

<a name="MockLoggerMockRecorder"></a>
## type [MockLoggerMockRecorder](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/rabbit/mock_logger.go#L26-L28>)

MockLoggerMockRecorder is the mock recorder for MockLogger.

```go
type MockLoggerMockRecorder struct {
    // contains filtered or unexported fields
}
```

<a name="MockLoggerMockRecorder.Debug"></a>
### func \(\*MockLoggerMockRecorder\) [Debug](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/rabbit/mock_logger.go#L53>)

```go
func (mr *MockLoggerMockRecorder) Debug(msg, err any, fields ...any) *gomock.Call
```

Debug indicates an expected call of Debug.

<a name="MockLoggerMockRecorder.Error"></a>
### func \(\*MockLoggerMockRecorder\) [Error](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/rabbit/mock_logger.go#L70>)

```go
func (mr *MockLoggerMockRecorder) Error(msg, err any, fields ...any) *gomock.Call
```

Error indicates an expected call of Error.

<a name="MockLoggerMockRecorder.Fatal"></a>
### func \(\*MockLoggerMockRecorder\) [Fatal](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/rabbit/mock_logger.go#L87>)

```go
func (mr *MockLoggerMockRecorder) Fatal(msg, err any, fields ...any) *gomock.Call
```

Fatal indicates an expected call of Fatal.

<a name="MockLoggerMockRecorder.Info"></a>
### func \(\*MockLoggerMockRecorder\) [Info](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/rabbit/mock_logger.go#L104>)

```go
func (mr *MockLoggerMockRecorder) Info(msg, err any, fields ...any) *gomock.Call
```

Info indicates an expected call of Info.

<a name="MockLoggerMockRecorder.Warn"></a>
### func \(\*MockLoggerMockRecorder\) [Warn](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/rabbit/mock_logger.go#L121>)

```go
func (mr *MockLoggerMockRecorder) Warn(msg, err any, fields ...any) *gomock.Call
```

Warn indicates an expected call of Warn.

<a name="Rabbit"></a>
## type [Rabbit](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/rabbit/setup.go#L38-L57>)

Rabbit represents a client for interacting with RabbitMQ. It manages connections, channels, and provides methods for publishing and consuming messages with automatic reconnection capabilities.

```go
type Rabbit struct {

    // Channel is the main AMQP channel used for publishing and consuming messages.
    // It's exposed publicly to allow direct operations when needed.
    Channel *amqp.Channel
    // contains filtered or unexported fields
}
```

<a name="NewClient"></a>
### func [NewClient](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/rabbit/setup.go#L74>)

```go
func NewClient(cfg Config, logger Logger) *Rabbit
```

NewClient creates and initializes a new RabbitMQ client with the provided configuration. This function establishes the initial connection to RabbitMQ, sets up channels, and configures exchanges and queues as specified in the configuration.

Parameters:

- cfg: Configuration for connecting to RabbitMQ and setting up channels
- logger: Logger implementation for recording events and errors

Returns a new Rabbit client instance that is ready to use. If connection fails after all retries or channel setup fails, it will log a fatal error.

Example:

```
client := rabbit.NewClient(config, myLogger)
defer client.Close()
```

<a name="Rabbit.Consume"></a>
### func \(\*Rabbit\) [Consume](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/rabbit/utils.go#L141>)

```go
func (rb *Rabbit) Consume(ctx context.Context, wg *sync.WaitGroup) <-chan Message
```

Consume starts consuming messages from the queue specified in the configuration. This method provides a channel where consumed messages will be delivered.

Parameters:

- ctx: Context for cancellation control
- wg: WaitGroup for coordinating shutdown

Returns a channel that delivers Message interfaces for each consumed message.

Example:

```
wg := &sync.WaitGroup{}
ctx, cancel := context.WithCancel(context.Background())
defer cancel()

msgChan := rabbitClient.Consume(ctx, wg)
for msg := range msgChan {
    // Process the message
    fmt.Println("Received:", string(msg.Body()))

    // Acknowledge successful processing
    if err := msg.AckMsg(); err != nil {
        log.Printf("Failed to ack message: %v", err)
    }
}
```

<a name="Rabbit.ConsumeDLQ"></a>
### func \(\*Rabbit\) [ConsumeDLQ](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/rabbit/utils.go#L170>)

```go
func (rb *Rabbit) ConsumeDLQ(ctx context.Context, wg *sync.WaitGroup) <-chan Message
```

ConsumeDLQ starts consuming messages from the dead\-letter queue. This method is useful for processing failed messages sent to the dead\-letter queue.

Parameters:

- ctx: Context for cancellation control
- wg: WaitGroup for coordinating shutdown

Returns a channel that delivers Message interfaces for each consumed message from the dead\-letter queue.

Example:

```
wg := &sync.WaitGroup{}
ctx, cancel := context.WithCancel(context.Background())
defer cancel()

dlqChan := rabbitClient.ConsumeDLQ(ctx, wg)
for msg := range dlqChan {
    // Process the failed message
    fmt.Println("Failed message:", string(msg.Body()))

    // Acknowledge after processing
    msg.AckMsg()
}
```

<a name="Rabbit.Publish"></a>
### func \(\*Rabbit\) [Publish](<https://gitlab.aleph-alpha.de/engineering/pharia-data-search/data-go-packages/blob/main/pkg/rabbit/utils.go#L194>)

```go
func (rb *Rabbit) Publish(ctx context.Context, msg []byte) error
```

Publish sends a message to the RabbitMQ exchange specified in the configuration. This method is thread\-safe and respects context cancellation.

Parameters:

- ctx: Context for cancellation control
- msg: Message payload as a byte slice

Returns an error if publishing fails or if the context is canceled.

Example:

```
ctx := context.Background()
message := []byte("Hello, RabbitMQ!")

err := rabbitClient.Publish(ctx, message)
if err != nil {
    log.Printf("Failed to publish message: %v", err)
} else {
    log.Println("Message published successfully")
}
```

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
